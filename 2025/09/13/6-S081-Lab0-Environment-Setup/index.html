<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>6.S081_Lab0_Environment Setup | lzx's Blog</title><meta name="author" content="lzx"><meta name="copyright" content="lzx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="6.S081_Lab0_Environment Setup 写在前面 本文旨在为 MIT 6.S081: Operating System Engineering (RISC-V 版本) 的学习者提供一份完整、详尽的开发与调试环境搭建步骤。一个配置完善的环境是高效完成课程实验、深入理解操作系统内核的关键。本教程将引导你完成从安装工具链到配置图形化调试环境的全过程。 第一部分：基础概念 在开始配置前">
<meta property="og:type" content="article">
<meta property="og:title" content="6.S081_Lab0_Environment Setup">
<meta property="og:url" content="https://taffy128.github.io/2025/09/13/6-S081-Lab0-Environment-Setup/index.html">
<meta property="og:site_name" content="lzx&#39;s Blog">
<meta property="og:description" content="6.S081_Lab0_Environment Setup 写在前面 本文旨在为 MIT 6.S081: Operating System Engineering (RISC-V 版本) 的学习者提供一份完整、详尽的开发与调试环境搭建步骤。一个配置完善的环境是高效完成课程实验、深入理解操作系统内核的关键。本教程将引导你完成从安装工具链到配置图形化调试环境的全过程。 第一部分：基础概念 在开始配置前">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://taffy128.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-09-13T09:17:27.009Z">
<meta property="article:modified_time" content="2025-09-13T09:18:10.581Z">
<meta property="article:author" content="lzx">
<meta property="article:tag" content="C++学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://taffy128.github.io/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "6.S081_Lab0_Environment Setup",
  "url": "https://taffy128.github.io/2025/09/13/6-S081-Lab0-Environment-Setup/",
  "image": "https://taffy128.github.io/img/avatar.jpg",
  "datePublished": "2025-09-13T09:17:27.009Z",
  "dateModified": "2025-09-13T09:18:10.581Z",
  "author": [
    {
      "@type": "Person",
      "name": "lzx",
      "url": "https://taffy128.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://taffy128.github.io/2025/09/13/6-S081-Lab0-Environment-Setup/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '6.S081_Lab0_Environment Setup',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #FFB6C1;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/CS%20106L/"><span> CS 106L</span></a></li><li><a class="site-page child" href="/categories/%E5%86%85%E5%AD%98%E6%B1%A0/"><span> 内存池</span></a></li><li><a class="site-page child" href="/categories/6-S081/"><span> 6.S081</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">lzx's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">6.S081_Lab0_Environment Setup</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/CS%20106L/"><span> CS 106L</span></a></li><li><a class="site-page child" href="/categories/%E5%86%85%E5%AD%98%E6%B1%A0/"><span> 内存池</span></a></li><li><a class="site-page child" href="/categories/6-S081/"><span> 6.S081</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">6.S081_Lab0_Environment Setup</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-13T09:17:27.009Z" title="发表于 2025-09-13 17:17:27">2025-09-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-13T09:18:10.581Z" title="更新于 2025-09-13 17:18:10">2025-09-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/6-S081/">6.S081</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>6.S081_Lab0_Environment Setup</h1>
<h2 id="写在前面">写在前面</h2>
<p>本文旨在为 MIT 6.S081: Operating System Engineering (RISC-V 版本) 的学习者提供一份完整、详尽的开发与调试环境搭建步骤。一个配置完善的环境是高效完成课程实验、深入理解操作系统内核的关键。本教程将引导你完成从安装工具链到配置图形化调试环境的全过程。</p>
<h2 id="第一部分：基础概念">第一部分：基础概念</h2>
<p>在开始配置前，理解以下几个核心概念，有助于清晰地认识整个开发与调试工作流。</p>
<h4 id="1-1-宿主机-Host-与客户机-Guest">1.1. 宿主机 (Host) 与客户机 (Guest)</h4>
<p>整个开发过程涉及两个相互独立的系统环境：</p>
<ul>
<li><strong>宿主操作系统 (Host OS)</strong>：这是你用于开发和编译的系统，通常是一个 Linux 发行版（如 Ubuntu）。所有的开发工具，包括编译器、模拟器和调试器，都安装并运行在宿主机上。</li>
<li><strong>客户操作系统 (Guest OS)</strong>：这是你正在学习和开发的操作系统，即 <strong>xv6</strong>。它运行在由模拟器创建的独立虚拟环境中。</li>
</ul>
<h4 id="1-2-QEMU-的角色">1.2. QEMU 的角色</h4>
<p>QEMU 是一个开源的系统模拟器。在本课程中，它的作用是提供一个完整的、软件模拟的 RISC-V 架构计算机硬件平台。xv6 操作系统 (Guest OS) 便运行在这个由 QEMU 模拟出的虚拟硬件之上。这样做避免了对物理硬件的依赖，并提供了安全、可控的实验环境。</p>
<h4 id="1-3-GDB-远程调试模型">1.3. GDB 远程调试模型</h4>
<p>课程中的调试采用客户端-服务端 (Client-Server) 模型：</p>
<ul>
<li><strong>服务端 (Server)</strong>：QEMU 在启动时可以进入一种特殊模式，暂停 Guest OS (xv6) 的运行，并开放一个网络端口，等待调试器连接。</li>
<li><strong>客户端 (Client)</strong>：GDB (The GNU Debugger) 作为客户端，通过指定的网络端口连接到 QEMU 服务端。连接建立后，GDB 就可以从宿主机发送指令，来控制和检查客户机 (xv6) 的内部状态（如内存、寄存器、代码执行等）。</li>
</ul>
<h2 id="第二部分：环境搭建">第二部分：环境搭建</h2>
<h4 id="2-1-准备-Linux-环境">2.1. 准备 Linux 环境</h4>
<p>课程实验需要在基于 Debian/Ubuntu 的 Linux 环境下进行。我们推荐以下几种方式来准备该环境：</p>
<ul>
<li><strong>对于 Windows 用户</strong>：强烈推荐使用 <strong>WSL 2 (Windows Subsystem for Linux 2)</strong>。WSL 2 提供了一个在 Windows 系统内运行的、性能优越的完整 Linux 内核环境。请从 Microsoft Store 安装 Ubuntu 20.04 或更高版本。</li>
<li><strong>对于 macOS / Linux 用户</strong>：可以直接使用系统自带的终端环境。</li>
<li><strong>云服务器选项</strong>：使用云服务提供商（如阿里云、AWS、Google Cloud 等）的虚拟机，并选择 Ubuntu 20.04 或更高版本的镜像是另一种优秀、隔离性强的选择。</li>
</ul>
<h4 id="2-2-安装核心工具链">2.2. 安装核心工具链</h4>
<p>在你的 Ubuntu 环境中，执行以下命令安装所有必需的软件包：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 更新软件包列表，确保能找到最新的软件</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 安装所有依赖</span><br><span class="line"># - git: 版本控制工具，用于下载源码</span><br><span class="line"># - build-essential: 包含了 make, gcc 等基础编译工具</span><br><span class="line"># - gdb-multiarch: 支持多种架构的 GDB 调试器，课程核心！</span><br><span class="line"># - qemu-system-riscv64: RISC-V 架构的 QEMU 模拟器</span><br><span class="line"># - gcc-riscv64-linux-gnu: RISC-V 的交叉编译器</span><br><span class="line"># - binutils-riscv64-linux-gnu: RISC-V 的二进制工具集</span><br><span class="line">sudo apt install git build-essential gdb-multiarch qemu-system-riscv64 gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu -y</span><br></pre></td></tr></table></figure>
<h4 id="2-3-获取-xv6-源代码">2.3. 获取 xv6 源代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 建议在用户主目录下进行操作</span><br><span class="line">cd ~</span><br><span class="line"></span><br><span class="line"># 克隆源代码 (以<span class="number">2023</span>年版本为例)</span><br><span class="line">git clone git:<span class="comment">//g.csail.mit.edu/xv6-labs-2023.git</span></span><br><span class="line"></span><br><span class="line"># 进入代码目录</span><br><span class="line">cd xv6-labs<span class="number">-2023</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>git://</code> 协议因网络问题无法连接，可以尝试使用 <code>https://</code> 协议：<code>git clone https://g.csail.mit.edu/xv6-labs-2023.git</code>。</p>
<h2 id="第三部分：工作流验证">第三部分：工作流验证</h2>
<h4 id="3-1-首次启动：编译并运行-xv6">3.1. 首次启动：编译并运行 xv6</h4>
<p>验证环境是否能成功编译并运行 xv6。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 确认当前位于 xv6-labs<span class="number">-2023</span> 目录下</span><br><span class="line">pwd</span><br><span class="line"></span><br><span class="line"># 运行编译和启动命令 (非调试模式)</span><br><span class="line">make qemu</span><br></pre></td></tr></table></figure>
<p>终端应显示编译信息，随后是 xv6 的启动日志，最后停在 <code>$</code> 提示符。</p>
<p><strong>重要</strong>：按 <code>Ctrl+a</code> 组合键，然后松开，再按 <code>x</code> 键，即可退出 QEMU。</p>
<h4 id="3-2-命令行-GDB-调试验证">3.2. 命令行 GDB 调试验证</h4>
<p>验证 GDB 远程调试通路是否正常。此步骤需要使用两个终端。</p>
<ul>
<li><strong>终端 1 (启动 QEMU 服务端):</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在 xv6-labs<span class="number">-2023</span> 目录下</span><br><span class="line">make qemu-gdb</span><br></pre></td></tr></table></figure>
<p>此终端将启动 QEMU 并等待 GDB 连接，会显示监听的端口号（如 <code>tcp::25000</code>）并暂停执行。</p>
<ul>
<li><strong>终端 2 (运行 GDB 客户端):</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 也在 xv6-labs<span class="number">-2023</span> 目录下</span><br><span class="line"># 启动支持 RISC-V 的 GDB</span><br><span class="line">gdb-multiarch</span><br><span class="line"></span><br><span class="line"># 在 (gdb) 提示符下，连接到 <span class="built_in">QEMU</span> (端口号替换为终端<span class="number">1</span>显示的端口)</span><br><span class="line">(gdb) target remote localhost:<span class="number">25000</span></span><br><span class="line"></span><br><span class="line"># 设置断点并继续运行以测试</span><br><span class="line">(gdb) b _entry</span><br><span class="line">(gdb) c</span><br></pre></td></tr></table></figure>
<p>如果程序成功在 <code>_entry</code> 处暂停，说明基础调试环境已配置成功。使用 <code>quit</code> 命令退出 GDB。</p>
<h2 id="第四部分：高级配置：VSCode-远程开发与调试">第四部分：高级配置：VSCode 远程开发与调试</h2>
<p>为了极大地提升开发和调试效率，强烈推荐配置 VSCode 实现图形化的远程调试。</p>
<h4 id="4-1-安装-VSCode-和必备插件">4.1. 安装 VSCode 和必备插件</h4>
<p>在你的<strong>本地计算机</strong>上安装 Visual Studio Code，并从插件市场安装以下插件：</p>
<ol>
<li><code>Remote - SSH</code>：用于连接远程服务器，直接在本地 VSCode 编辑服务器上的文件。</li>
<li><code>C/C++ Extension Pack</code>：提供 C/C++ 语言智能提示、代码跳转和调试支持。</li>
</ol>
<h4 id="4-2-连接到远程服务器">4.2. 连接到远程服务器</h4>
<ol>
<li>在 VSCode 中按 <code>F1</code> 或 <code>Ctrl+Shift+P</code>，运行 <code>Remote-SSH: Connect to Host...</code> 命令。</li>
<li>根据提示添加你的 Linux 环境的 SSH 连接信息（例如 <code>ssh username@ip_address</code>）。</li>
<li>连接成功后，通过 <code>File &gt; Open Folder...</code> 打开位于服务器上的 <code>~/xv6-labs-2023</code> 文件夹。</li>
</ol>
<h4 id="4-3-创建-launch-json-调试配置文件">4.3. 创建 <code>launch.json</code> 调试配置文件</h4>
<ol>
<li>在 VSCode 中打开 <code>xv6-labs-2023</code> 文件夹后，切换到“运行和调试 (Run and Debug)”侧边栏。</li>
<li>点击 “create a launch.json file”，选择 “C++ (GDB/LLDB)”，然后选择 “Default Configuration”。</li>
<li>用以下内容<strong>完全替换</strong>自动生成的 <code>launch.json</code> 文件：</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;XV6-Debug (Attach to QEMU)&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 指定调试器需要加载符号表的可执行文件</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/kernel/kernel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// GDB 进程的工作目录</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 在程序入口处自动暂停</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 显式指定 gdb-multiarch 的路径</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb-multiarch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// GDB 要连接的 QEMU 服务端地址和端口</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost:25000&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：请确保 <code>&quot;miDebuggerServerAddress&quot;</code> 中的端口号与 <code>make qemu-gdb</code> 命令显示的端口号一致。</p>
<h4 id="4-4-图形化调试流程">4.4. 图形化调试流程</h4>
<ol>
<li>在 VSCode 的集成终端中（<code>Terminal &gt; New Terminal</code>），运行 <code>make qemu-gdb</code> 启动 QEMU 服务端。</li>
<li>在 VSCode 编辑器中打开任意内核源代码文件（如 <code>kernel/proc.c</code>），在行号左侧单击以设置断点（红色圆点）。</li>
<li>切换到“运行和调试”侧边栏，按下 <code>F5</code> 键或点击绿色的“启动调试”按钮。</li>
</ol>
<p>此时，VSCode 将自动连接到 QEMU，xv6 继续执行直到命中你设置的断点。你可以在 VSCode 界面中直观地查看变量值、调用栈，并使用按钮进行单步执行等操作。</p>
<p>完成以上所有步骤后，你的开发环境即已准备就绪。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://taffy128.github.io/">lzx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://taffy128.github.io/2025/09/13/6-S081-Lab0-Environment-Setup/">https://taffy128.github.io/2025/09/13/6-S081-Lab0-Environment-Setup/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://taffy128.github.io" target="_blank">lzx's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">C++学习笔记</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/13/6-S081-Lab1-Unix-Utilities/" title="6.S081_Lab1_Unix Utilities"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">6.S081_Lab1_Unix Utilities</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab1_Unix Utilities 写在前面 这是本课程第一次正式Lab，自行完成需要耗费一定的时间 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab1地址 课程首页 0.Makefile 每个任务完成之后需要在Makefile中添加对应的信息才能运行 在UPROGS项下添加以下内容： 12345$U/_sleep\$U/_pingpong\$U/_primes\$U/_find\$U/_xargs\ 1.Sleep 通过sleep系统调用来实现休眠一定时间，注意如果没有传入参数，程序需要打印错误信息 1234567891011#include &quot;kernel/types.h&quot;#include...</div></div></div></a><a class="pagination-related" href="/2025/09/01/C-%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%B1%A0-%E7%89%88%E6%9C%AC2/" title="C++项目——内存池_v2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++项目——内存池_v2</div></div><div class="info-2"><div class="info-item-1">C++项目——内存池_版本2 前置知识 自旋锁的概念 自旋锁是一种 轻量级的锁机制，用于实现线程同步。当一个线程尝试获取锁时，如果锁已经被其他线程占用，它不会进入阻塞状态，而是 不断尝试获取锁，直到成功。这种“忙等”行为就叫 “自旋”。 在**fetchRange**函数代码中的部分：   test_and_set()是 原子操作，它将locks_[index]设置为true，并返回锁的原始状态。   如果返回值表示锁已经被占用（true），线程会继续尝试获取锁（自旋）。   这种方式避免了线程切换的开销。   自旋锁 vs. 互斥锁    自旋锁 互斥锁     忙等，反复尝试获取锁 阻塞，线程会被挂起   适合锁持有时间很短的场景 适合锁持有时间较长的场景   无需操作系统上下文切换，性能高 需要上下文切换，开销较大    项目框架 为什么实现了内存池版本1还要实现内存池版本2...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/10/18/6-S081-Lab5-Copy-on-write-fork/" title="6.S081_Lab5_Copy-on-write fork"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-18</div><div class="info-item-2">6.S081_Lab5_Copy-on-write fork</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab5_Copy-on-write fork 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 页面引用计数（Page Refcount） 这部分的代码都修改于 kalloc.c。 在 Linux 内核中，有 struct page 数据结构来对应每一个 page 的 metadata。在 Xv6 中，我定义了一个 _refcount 数组，来表示每个 page 的引用计数，引用计数为 0 表示 page 可以被释放。这里我用了一个锁来保护 _refcount 字段 123#define PAGE_IDX(pa) (((uint64)pa - (uint64)end) &gt;&gt; PGSHIFT)static int...</div></div></div></a><a class="pagination-related" href="/2025/09/20/6-S081-Lab3-page-tables/" title="6.S081_Lab3_page tables"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-20</div><div class="info-item-2">6.S081_Lab3_page tables</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab3_page tables 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab3地址 课程首页 1.Speed up system calls 要求：通过在内核与用户空间之间共享一个只读内存页来加速getpid()系统调用，具体做法是在创建进程时分配一个物理页、存入PID，然后将其以只读方式映射到用户虚拟地址USYSCALL，并在进程退出时释放它，从而让用户程序可以直接从内存读取PID，避免陷入内核。 这个 task 的难点在于，你应该把 map page 这段代码放在哪里最合适？Lab 文档里说的是 When each process is created，具体是什么时候呢？是放在 fork 的地方，还是放在 allocproc...</div></div></div></a><a class="pagination-related" href="/2025/09/27/6-S081-Lab4-Traps/" title="6.S081_Lab4_Traps"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-27</div><div class="info-item-2">6.S081_Lab4_Traps</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab4_Traps 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab4地址 课程首页 1.RISC-V assembly 要求：使用make fs.img编译，得到user/call.asm文件，通过阅读call.asm，了解g、f和main函数，并回答以下问题   Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf? a1 里存 12（第一个参数），a2 里存 13（第二个参数），a1、a2 包含函数参数。    Where is the call to function f...</div></div></div></a><a class="pagination-related" href="/2025/09/01/C-%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%B1%A0-%E7%89%88%E6%9C%AC2/" title="C++项目——内存池_v2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-01</div><div class="info-item-2">C++项目——内存池_v2</div></div><div class="info-2"><div class="info-item-1">C++项目——内存池_版本2 前置知识 自旋锁的概念 自旋锁是一种 轻量级的锁机制，用于实现线程同步。当一个线程尝试获取锁时，如果锁已经被其他线程占用，它不会进入阻塞状态，而是 不断尝试获取锁，直到成功。这种“忙等”行为就叫 “自旋”。 在**fetchRange**函数代码中的部分：   test_and_set()是 原子操作，它将locks_[index]设置为true，并返回锁的原始状态。   如果返回值表示锁已经被占用（true），线程会继续尝试获取锁（自旋）。   这种方式避免了线程切换的开销。   自旋锁 vs. 互斥锁    自旋锁 互斥锁     忙等，反复尝试获取锁 阻塞，线程会被挂起   适合锁持有时间很短的场景 适合锁持有时间较长的场景   无需操作系统上下文切换，性能高 需要上下文切换，开销较大    项目框架 为什么实现了内存池版本1还要实现内存池版本2...</div></div></div></a><a class="pagination-related" href="/2025/07/22/CS106L-Winter2025-Assignment1-SimpleEnroll/" title="CS106L Winter2025 Assignment1 SimpleEnroll"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-22</div><div class="info-item-2">CS106L Winter2025 Assignment1 SimpleEnroll</div></div><div class="info-2"><div class="info-item-1">CS106L Winter2025 Assignment1 SimpleEnroll 写在前面 作业地址：CS106L Winter2025 Assignment 以下是Stanford CS106L的第一个作业，需要在学完Containers后完成 具体思路 Part 0: Read the code and fill in the Course...</div></div></div></a><a class="pagination-related" href="/2025/09/01/C-%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%B1%A0-%E7%89%88%E6%9C%AC1/" title="C++项目——内存池_v1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-01</div><div class="info-item-2">C++项目——内存池_v1</div></div><div class="info-2"><div class="info-item-1">C++项目——内存池_版本1 前置知识 std::allocator c++中所有stl容器都有自己的allocator类用于分配和回收空间，例如vector类中push_back函数的实现方式： 123456789template &lt;class T&gt;void Vector&lt;T&gt;::push_back(const T&amp; t)&#123;// are we out of space?	if (first_free == end)		reallocate(); // gets more space and copies existing elements to it	alloc.construct(first_free,...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">lzx</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Taffy128"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Taffy128" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yyangguangnanhai9@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">6.S081_Lab0_Environment Setup</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">第一部分：基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%AE%BF%E4%B8%BB%E6%9C%BA-Host-%E4%B8%8E%E5%AE%A2%E6%88%B7%E6%9C%BA-Guest"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">1.1. 宿主机 (Host) 与客户机 (Guest)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-QEMU-%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">1.2. QEMU 的角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-GDB-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">1.3. GDB 远程调试模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.3.</span> <span class="toc-text">第二部分：环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%87%86%E5%A4%87-Linux-%E7%8E%AF%E5%A2%83"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">2.1. 准备 Linux 环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%AE%89%E8%A3%85%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E9%93%BE"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">2.2. 安装核心工具链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E8%8E%B7%E5%8F%96-xv6-%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">2.3. 获取 xv6 源代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E5%B7%A5%E4%BD%9C%E6%B5%81%E9%AA%8C%E8%AF%81"><span class="toc-number">1.4.</span> <span class="toc-text">第三部分：工作流验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%A6%96%E6%AC%A1%E5%90%AF%E5%8A%A8%EF%BC%9A%E7%BC%96%E8%AF%91%E5%B9%B6%E8%BF%90%E8%A1%8C-xv6"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">3.1. 首次启动：编译并运行 xv6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%91%BD%E4%BB%A4%E8%A1%8C-GDB-%E8%B0%83%E8%AF%95%E9%AA%8C%E8%AF%81"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">3.2. 命令行 GDB 调试验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%EF%BC%9A%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%EF%BC%9AVSCode-%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-number">1.5.</span> <span class="toc-text">第四部分：高级配置：VSCode 远程开发与调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%AE%89%E8%A3%85-VSCode-%E5%92%8C%E5%BF%85%E5%A4%87%E6%8F%92%E4%BB%B6"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">4.1. 安装 VSCode 和必备插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">4.2. 连接到远程服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%88%9B%E5%BB%BA-launch-json-%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">4.3. 创建 launch.json 调试配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E5%9B%BE%E5%BD%A2%E5%8C%96%E8%B0%83%E8%AF%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.0.4.</span> <span class="toc-text">4.4. 图形化调试流程</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/18/6-S081-Lab5-Copy-on-write-fork/" title="6.S081_Lab5_Copy-on-write fork">6.S081_Lab5_Copy-on-write fork</a><time datetime="2025-10-18T09:40:41.145Z" title="发表于 2025-10-18 17:40:41">2025-10-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/27/6-S081-Lab4-Traps/" title="6.S081_Lab4_Traps">6.S081_Lab4_Traps</a><time datetime="2025-09-27T10:04:55.181Z" title="发表于 2025-09-27 18:04:55">2025-09-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/20/6-S081-Lab3-page-tables/" title="6.S081_Lab3_page tables">6.S081_Lab3_page tables</a><time datetime="2025-09-20T03:11:15.463Z" title="发表于 2025-09-20 11:11:15">2025-09-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/13/6-S081-Lab2-System-calls/" title="6.S081_Lab2_System calls">6.S081_Lab2_System calls</a><time datetime="2025-09-13T09:33:55.752Z" title="发表于 2025-09-13 17:33:55">2025-09-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/13/6-S081-Lab1-Unix-Utilities/" title="6.S081_Lab1_Unix Utilities">6.S081_Lab1_Unix Utilities</a><time datetime="2025-09-13T09:30:35.779Z" title="发表于 2025-09-13 17:30:35">2025-09-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By lzx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>