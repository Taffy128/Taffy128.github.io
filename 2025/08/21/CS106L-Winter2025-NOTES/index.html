<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CS106L Winter2025 NOTES | lzx's Blog</title><meta name="author" content="lzx"><meta name="copyright" content="lzx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CS106L Winter2025 NOTES 1. Types and Structs 1.1 什么是C++？ 1. C++是编译型语言，不同于python，python是解释型语言，作为编译型语言，C++有以下特点：  生成的机器语言更高效，因为编译器可以看到一切，但是解释器只能看到代码的一小部分 编译需要的时间更长  2. C++的报错信息更加冗杂…为什么？  C++是静态类型语言，这意味着">
<meta property="og:type" content="article">
<meta property="og:title" content="CS106L Winter2025 NOTES">
<meta property="og:url" content="https://taffy128.github.io/2025/08/21/CS106L-Winter2025-NOTES/index.html">
<meta property="og:site_name" content="lzx&#39;s Blog">
<meta property="og:description" content="CS106L Winter2025 NOTES 1. Types and Structs 1.1 什么是C++？ 1. C++是编译型语言，不同于python，python是解释型语言，作为编译型语言，C++有以下特点：  生成的机器语言更高效，因为编译器可以看到一切，但是解释器只能看到代码的一小部分 编译需要的时间更长  2. C++的报错信息更加冗杂…为什么？  C++是静态类型语言，这意味着">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://taffy128.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-08-21T01:54:55.317Z">
<meta property="article:modified_time" content="2025-08-21T08:30:20.925Z">
<meta property="article:author" content="lzx">
<meta property="article:tag" content="C++学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://taffy128.github.io/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CS106L Winter2025 NOTES",
  "url": "https://taffy128.github.io/2025/08/21/CS106L-Winter2025-NOTES/",
  "image": "https://taffy128.github.io/img/avatar.jpg",
  "datePublished": "2025-08-21T01:54:55.317Z",
  "dateModified": "2025-08-21T08:30:20.925Z",
  "author": [
    {
      "@type": "Person",
      "name": "lzx",
      "url": "https://taffy128.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://taffy128.github.io/2025/08/21/CS106L-Winter2025-NOTES/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CS106L Winter2025 NOTES',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #FFB6C1;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/CS%20106L/"><span> CS 106L</span></a></li><li><a class="site-page child" href="/categories/%E5%86%85%E5%AD%98%E6%B1%A0/"><span> 内存池</span></a></li><li><a class="site-page child" href="/categories/6-S081/"><span> 6.S081</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">lzx's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">CS106L Winter2025 NOTES</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/CS%20106L/"><span> CS 106L</span></a></li><li><a class="site-page child" href="/categories/%E5%86%85%E5%AD%98%E6%B1%A0/"><span> 内存池</span></a></li><li><a class="site-page child" href="/categories/6-S081/"><span> 6.S081</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CS106L Winter2025 NOTES</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-21T01:54:55.317Z" title="发表于 2025-08-21 09:54:55">2025-08-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-21T08:30:20.925Z" title="更新于 2025-08-21 16:30:20">2025-08-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS106L/">CS106L</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>CS106L Winter2025 NOTES</h1>
<h2 id="1-Types-and-Structs">1. Types and Structs</h2>
<h3 id="1-1-什么是C-？">1.1 什么是C++？</h3>
<p><strong>1. C++是编译型语言，不同于python，python是解释型语言，作为编译型语言，C++有以下特点：</strong></p>
<ul>
<li>生成的机器语言更高效，因为编译器可以看到一切，但是解释器只能看到代码的一小部分</li>
<li>编译需要的时间更长</li>
</ul>
<p><strong>2. C++的报错信息更加冗杂…为什么？</strong></p>
<ul>
<li>C++是静态类型语言，这意味着：<br>
1. 每个变量必须社声明类型<br>
1. 一旦声明，变量类型不能改变</li>
<li>静态类型的有点：
<ol>
<li>更加高效</li>
<li>更易于理解和推理</li>
<li><strong>更好的错误检查</strong></li>
</ol>
</li>
</ul>
<h3 id="1-2-Structs">1.2 Structs</h3>
<h4 id="1-2-1-结构体基础">1.2.1 结构体基础</h4>
<ol>
<li>
<p>定义结构体</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">StanfordID</span> &#123;</span><br><span class="line">	string name; <span class="comment">// These are called fields</span></span><br><span class="line">	string sunet; <span class="comment">// Each has a name and type</span></span><br><span class="line">	<span class="type">int</span> idNumber;</span><br><span class="line">&#125;;</span><br><span class="line">StanfordID id; <span class="comment">// Initialize struct</span></span><br><span class="line">id.name = <span class="string">&quot;Jacob Roberts-Baca&quot;</span>; <span class="comment">// Access field with ‘.’</span></span><br><span class="line">id.sunet = <span class="string">&quot;jtrb&quot;</span>;</span><br><span class="line">id.idNumber = <span class="number">6504417</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>返回多个值</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StanfordID <span class="title">issueNewID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	StanfordID id;</span><br><span class="line">	id.name = <span class="string">&quot;Jacob Roberts-Baca&quot;</span>;</span><br><span class="line">	id.sunet = <span class="string">&quot;jtrb&quot;</span>;</span><br><span class="line">	id.idNumber = <span class="number">6504417</span>;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>列表初始化</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StanfordID jrb = &#123; <span class="string">&quot;Jacob Roberts-Baca&quot;</span>,<span class="string">&quot;jtrb&quot;</span>, <span class="number">6504417</span> &#125;;</span><br><span class="line">StanfordID fi &#123; ”Fabio Ibanez<span class="string">&quot;,”fibanez&quot;</span>, <span class="number">6504418</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>std::pair</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当我们想要表示两个值作为一个结构体时，STL已经给出了模板--std::pair</span></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">	std::string item;</span><br><span class="line">	<span class="type">int</span> quantity;</span><br><span class="line">&#125;</span><br><span class="line">Order dozen = &#123;<span class="string">&quot;Eggs&quot;</span>, <span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::pair</span></span><br><span class="line">std::pair&lt;std::string, <span class="type">int</span>&gt; dozen &#123;<span class="string">&quot;Eggs&quot;</span>, <span class="number">12</span>&#125;;</span><br><span class="line">std::string item = dozen.first;</span><br><span class="line"><span class="type">int</span> quantity = dozen.second;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="1-2-2-什么是std？">1.2.2 什么是std？</h4>
<p><strong>std ― The C++ Standard Library</strong></p>
<ul>
<li>提供C++内置类型、函数和更多内容</li>
<li>需要用#include包含相关头文件
<ul>
<li>#include  → std::string</li>
<li>#include  → std::pair</li>
<li>#include  → std::cout, std::endl</li>
</ul>
</li>
<li>通常需要写前缀std::
<ul>
<li>除非我们在了<code>using namespace std;</code>，不过这是<strong>不好的习惯</strong></li>
</ul>
</li>
</ul>
<h3 id="1-3-改进我们的代码">1.3 改进我们的代码</h3>
<h4 id="1-3-1-使用using关键字">1.3.1 使用using关键字</h4>
<p>在遇到一些类型十分复杂的函数时，其往往会存在大量的、不好理解的类型，此时就可以使用<code>using</code>关键字，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 using 前</span></span><br><span class="line">std::pair&lt;<span class="type">bool</span>, std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt; <span class="built_in">solveQuadratic</span>(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 using 后</span></span><br><span class="line"><span class="keyword">using</span> Zeros = std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> Solution = std::pair&lt;<span class="type">bool</span>, Zeros&gt;;</span><br><span class="line"><span class="function">Solution <span class="title">solveQuadratic</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-使用auto关键字">1.3.2 使用auto关键字</h4>
<p>有时我们自己也搞不清这个变量到底是什么类型，那么此时就可以使用<code>auto</code>关键字，让编译器自己判断这个变量到底是什么类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 auto 前</span></span><br><span class="line">std::pair&lt;<span class="type">bool</span>, std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt; result = <span class="built_in">solveQuadratic</span>(a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 auto 后</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">solveQuadratic</span>(a, b, c);</span><br></pre></td></tr></table></figure>
<h2 id="2-Initialization-References">2.Initialization &amp; References</h2>
<h3 id="2-1-Initialization">2.1 Initialization</h3>
<h4 id="2-1-1-Direct-initialization">2.1.1 Direct initialization</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numOne = <span class="number">12.0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numTwo</span><span class="params">(<span class="number">12.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在<strong>直接初始化</strong>中，C++不在乎你的值是否满足<strong>类型检查</strong>，它只会简单地将其看作你给他赋予的类型，这通常被称为**“narrowing conversion(窄化转换)”**</p>
<h4 id="2-1-2-Uniform-initialization-C-11">2.1.2 Uniform initialization(C++11)</h4>
<p>对于统一初始化来说，<strong>C++在乎你的值满足类型检查</strong>，简单说，若你给的值是个浮点数，同时给的类型是<code>int</code>，那么此时编译器会给你一段报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numOne&#123;<span class="number">12</span>&#125;; <span class="comment">// !!花括号</span></span><br><span class="line"><span class="type">float</span> numTwo&#123;<span class="number">12.0</span>&#125;; <span class="comment">// !!花括号</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> numThree&#123;<span class="number">12.0</span>&#125; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p><strong>优点</strong></p>
<ol>
<li>安全性：不允许发生<strong>窄化转换</strong>，避免很多问题</li>
<li>泛用性：几乎所有类型都可以用这种方法来初始化</li>
</ol>
<h4 id="2-1-3-Structured-Bingding-C-17">2.1.3 Structured Bingding(C++17)</h4>
<ul>
<li>在编译时，想要初始化一些具有固定的大小且此变量是作为一个数据结构存在时就使用<strong>结构化绑定</strong></li>
<li>拥有从一个函数的返回值一次性访问多个值的能力 比如，我们现在创建一个函数<code>getClassInfo</code>，它是用<code>tuple</code>这个数据结构来实现的，返回值使用的是<strong>统一初始化</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, std::string, std::string&gt; <span class="title">getClassInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::string className = <span class="string">&quot;CS106L&quot;</span>;</span><br><span class="line">	std::string buildingName = <span class="string">&quot;Thornton 110&quot;</span>;</span><br><span class="line">	std::string language = <span class="string">&quot;C++&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> &#123;className, buildingName, language&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就可以把这个函数返回的三个值用<strong>结构化绑定</strong>的方法来返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> [className, buildingName, lanuage] = <span class="built_in">getClassInfo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，还可以通过<code>get</code>来获取函数返回值，注意这里需要<strong>用&lt;&gt;来指定</strong>取用第几个元素</p>
<ul>
<li>可以在编译时对已知大小的对象上使用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> classInfo = <span class="built_in">getClassInfo</span>();</span><br><span class="line">	std::string className = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(classInfo);</span><br><span class="line">	std::string buildingName = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(classInfo);</span><br><span class="line">	std::string language = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(classInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-References">2.2 References</h3>
<h4 id="2-2-1-References简单介绍">2.2.1 References简单介绍</h4>
<ul>
<li>
<p>什么是<strong>References</strong>？</p>
<p>给一个已经存在的对象或函数起别名</p>
</li>
<li>
<p>如何表示<strong>References</strong>？</p>
<p>使用<code>&amp;</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = num;</span><br><span class="line"></span><br><span class="line">ref = <span class="number">10</span>;</span><br><span class="line">std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// Output: 10</span></span><br></pre></td></tr></table></figure>
<p>num是一个整数类型变量，值为5；ref是一个整数引用类型变量，值为num，即num的别名。当我们更改ref的值时，也是在更改num的值。即ref是指向num的一个指针，这就是<strong>Pass by reference（按引用传递）</strong></p>
<h4 id="2-2-2-Pass-by-reference">2.2.2 Pass by reference</h4>
<p>当我们在函数中声明参数为引用类型时，即代表此函数使用的是<strong>pass by reference</strong>，这也就意味着，我们不会在内存中再分配一块内存来复制此变量等执行一系列操作，只会在原内存上操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">squareN</span><span class="params">(<span class="type">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">	n = std::<span class="built_in">pow</span>(n, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">squareN</span>(num);</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="comment">//Output: 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-Passing-by-value">2.2.3 Passing by value</h4>
<p>这意味着我们会在内存中重新分配一块内存，并将原参数复制一份过来，不会在原内存上进行操作，不会影响原内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">squareN</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	n = std::<span class="built_in">pow</span>(n, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">squareN</span>(num);</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="comment">//Output: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-按值传递与按引用传递易错点">2.2.4 按值传递与按引用传递易错点</h4>
<p>值得注意的是，当我们在遇见一些很复杂的类型时，会用到之前学到的<strong>auto</strong>，同时还用了<strong>Structred Binding</strong>但在进行按引用传递时，编译器不会帮我们寻找 <strong>&amp;</strong> 我们需要自己加上 <strong>&amp;</strong> 即</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shift</span><span class="params">(std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [num1, num2] : nums) &#123;</span><br><span class="line">		num1++;</span><br><span class="line">		num2++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但当我们用普通的<strong>点表达式</strong>时，就不需要这样，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shift</span><span class="params">(std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		nums[i].first++;</span><br><span class="line">		nums[i].second++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-L-values-vs-R-values">2.3 L-values vs R-values</h3>
<p>左值和右值是表达式的基本分类，用于描述其值类别，区别在于对象的身份、生命周期和可操纵性。 <strong>左值代表一个有持久状态的变量</strong>（或内存位置），通常可以取地址、有名称。<strong>可以出现在表达式的左边或右边</strong>。 <strong>右值代表一个临时变量或字面量</strong>，没有持久状态，不可以被取地址。<strong>出现在表达式的右边</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x为左值，10为右值</span></span><br><span class="line"><span class="type">int</span> y = x; <span class="comment">// 左值x既出现在表达式左边也出现在了表达式右边</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>对于<code>int&amp; num</code>是左值吗？</p>
<p>是左值。在这里，num是按引用传递，右值只可以存放临时变量，不可以被取地址，所以这里的num只能是左值。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">squareN</span><span class="params">(<span class="type">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> std::<span class="built_in">pow</span>(num, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> lValue = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">auto</span> four = <span class="built_in">squareN</span>(lValue);</span><br><span class="line"> 	<span class="keyword">auto</span> fourAgain = <span class="built_in">squareN</span>(<span class="number">2</span>); <span class="comment">// Output: 报错信息,用引用传递右值</span></span><br><span class="line"> 	std::cout &lt;&lt; four &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-Const">2.4 Const</h3>
<p>当一个对象以常数声明后，它就无法再被修改了。 比如，对于一个vector，若被声明为<code>const std::vector&lt;int&gt; const_vec;</code>，那么此时若对此vector使用<code>push_back</code>就会编译错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	std::vector&lt;<span class="type">int</span>&gt; vec&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; <span class="comment">/// a normal vector</span></span><br><span class="line"> 	<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; const_vec&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; <span class="comment">/// a const vector</span></span><br><span class="line"> 	std::vector&lt;<span class="type">int</span>&gt;&amp; ref_vec&#123; vec &#125;; <span class="comment">/// a reference to &#x27;vec&#x27;</span></span><br><span class="line"> 	<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; const_ref&#123; vec &#125;; <span class="comment">/// a const reference</span></span><br><span class="line"> 	vec.<span class="built_in">push_back</span>(<span class="number">3</span>); <span class="comment">/// this is ok!</span></span><br><span class="line"> 	const_vec.<span class="built_in">push_back</span>(<span class="number">3</span>); <span class="comment">/// no, this is const!</span></span><br><span class="line"> 	ref_vec.<span class="built_in">push_back</span>(<span class="number">3</span>); <span class="comment">/// this is ok, just a reference!</span></span><br><span class="line"> 	const_ref.<span class="built_in">push_back</span>(<span class="number">3</span>); <span class="comment">/// this is const, compiler error!</span></span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>你不能声明指向const变量的非const引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="comment">/// a const vector</span></span><br><span class="line"> 	<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; const_vec&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="comment">// 指向const变量的非const引用</span></span><br><span class="line"> 	std::vector&lt;<span class="type">int</span>&gt;&amp; bad_ref&#123; const_vec &#125;; <span class="comment">/// BAD</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; bad_ref&#123; const_vec &#125;; <span class="comment">/// Good!</span></span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-Compiling-C-programs">2.5 Compiling C++ programs</h3>
<ul>
<li>C++是一个编译性语言</li>
<li>存在一款软件——编译器</li>
<li>目前流行的编译器有<strong>clang</strong> <strong>g++</strong> <code>g++ -std=c++20 main.cpp -o main</code> 此命令的内容为 使用g++这个编译器在C++20的环境下编译main.cpp这个文件并将编译后的程序命名为main 最后使用<code>./main</code>来执行此程序。</li>
</ul>
<h2 id="3-Streams">3. Streams</h2>
<h3 id="3-1-什么是Streams？">3.1 什么是Streams？</h3>
<p>C++的一个普遍的Input/Output（IO）抽象，此抽象提供一系列接口，用于读取和写入数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello, World&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p><code>std::cout</code>是一个<code>std::ostream</code>的一个实例变量，代表标准输出流</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi;</span><br><span class="line">std::cin &gt;&gt; pi;</span><br></pre></td></tr></table></figure>
<p><code>std::cin</code>是一个<code>std::istream</code>的一个实例变量，代表标准输入流，用于读取内容 流允许以一种普遍的方式来解决数据问题</p>
<h3 id="3-2-stringstreams">3.2 stringstreams</h3>
<h4 id="3-2-1-stringstreams简单介绍">3.2.1 stringstreams简单介绍</h4>
<p>用于将字符串以流的方式表达 对于不同类型数据混合的情况很适用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string initial_quote = <span class="string">&quot;Bjarne Stroustrup C makes it easy to shoot yourself in the foot&quot;</span></span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; initial_quote;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者定义时直接初始化</span></span><br><span class="line"><span class="comment">// std::stringstream ss(initial_quote);</span></span><br></pre></td></tr></table></figure>
<p>将上文字符串以流的形式写入<code>ss</code>，并且<strong>最后存在<code>\n</code></strong></p>
<p>对于stringstreams来说，以空格来分割一个字符串即，此时<code>first = &quot;Bjarne&quot;</code> <code>last = Stoustrup</code> <code>language = C</code> 但此时我们想把最后剩余的其他内容都写入<code>extracted_quote</code>用这种方式就不可取，由此引入<code>getline()</code></p>
<h4 id="3-2-2-getline">3.2.2 getline()</h4>
<p><code>getline()</code>会读取一行的内容，以终结符(通常为<code>\n</code>)截止</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">getline</span>(ss, extracted_quote);</span><br></pre></td></tr></table></figure>
<h3 id="3-3-cout-and-cin">3.3 cout and cin</h3>
<h4 id="3-3-1-cout的背后原理">3.3.1 cout的背后原理</h4>
<p>当我们想将一个内容输出到终端或控制台时，应当使用<code>std::cout</code>和<code>&lt;&lt;</code>操作符，但仅这样没法输出到控制台，我们还需要加上<code>flush</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> tao = <span class="number">6.28</span>;</span><br><span class="line">std::cout &lt;&lt; tao;</span><br><span class="line">std::cout &lt;&lt; std::flush;</span><br></pre></td></tr></table></figure>
<p>在调用<code>endl</code>会隐式调用<code>flush</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> tao = <span class="number">6.28</span>;</span><br><span class="line">std::cout &lt;&lt; tao;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>当我们每次调用<code>flush</code>时，就会立马清空此处的内存，包括使用<code>endl</code>的时候，在做一个循环时，当我们不断打印一个内容再加上一个换行符，就会耗费许多内存，故<code>flush</code>操作是很昂贵的。 但是，C++作为一个聪明的语言，是会自己知道什么时候该<code>flush</code>的，每当此处内存满了之后，就会自动<code>flush</code></p>
<h3 id="3-4-Output-File-Streams">3.4 Output File Streams</h3>
<h4 id="3-4-1-Output-File-Streams的基本介绍">3.4.1 Output File Streams的基本介绍</h4>
<ul>
<li>输出文件流具有类型：<code>std::ofstream</code></li>
<li>通过&lt;&lt;操作符<strong>向文件写入</strong></li>
<li><code>std::ofstream</code> 的常见方法：<code>is_open()</code>、<code>open()</code>、<code>close()</code>、<code>fail()</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;hello.txt&quot;</span>)</span></span>; <span class="comment">// 创建一个流用于打开文件</span></span><br><span class="line">	<span class="keyword">if</span> (ofs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		ofs &lt;&lt; <span class="string">&quot;Hello CS106L&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125; <span class="comment">// 检查文件是否打开</span></span><br><span class="line">	ofs.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;this will not get written&quot;</span>; <span class="comment">//此内容不会写进</span></span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;hello.txt&quot;</span>); <span class="comment">//打开文件</span></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;this will though! It&#x27;s open again&quot;</span>; <span class="comment">// 此内容会写进文件</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-Input-File-Streams">3.5 Input File Streams</h3>
<h4 id="3-5-1-Input-File-Streams的基本介绍">3.5.1 Input File Streams的基本介绍</h4>
<ul>
<li>输入文件流具有类型：<code>std::ifstream</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">inputFileStreamExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;append.txt&quot;</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		std::string line;</span><br><span class="line">	 	std::<span class="built_in">getline</span>(ifs, line);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Read from the file: &quot;</span> &lt;&lt; line &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		std::string lineTwo;</span><br><span class="line">	 	std::<span class="built_in">getline</span>(ifs, lineTwo);</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Read from the file: &quot;</span> &lt;&lt; lineTwo &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-Input-Streams">3.6 Input Streams</h3>
<h4 id="3-6-1-Input-Streams的基本介绍">3.6.1 Input Streams的基本介绍</h4>
<ul>
<li>输入流具有类型<code>std::istream</code></li>
<li>使用&gt;&gt;操作符从输入流中读取</li>
</ul>
<h4 id="3-6-2-std-cin">3.6.2 std::cin</h4>
<ul>
<li><code>std::cin</code> 是带缓冲的（buffered）</li>
<li>可以把缓冲区想象成一个临时存储区，用户先输入数据，程序再从缓冲区读取。</li>
<li><code>std::cin</code> 的读取在遇到 “ 空白字符 ” 时会停止。</li>
<li>C++ 中的空白字符包括：
<ul>
<li>空格（space）</li>
<li>换行符（newline）</li>
<li>制表符（tab）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> pi;</span><br><span class="line">	<span class="comment">// std::cin;</span></span><br><span class="line">	std::cin &gt;&gt; pi;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;pi is: &quot;</span> &lt;&lt; pi &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-6-3-当std-cin失败时">3.6.3 当std::cin失败时</h4>
<p><img src="/images/CS-106L-2.jpg" alt="CS 106L2"></p>
<p>不能简单的用一个<code>std::cin</code>和一个<code>std::getline</code>就读取pi 和 name</p>
<p>因为<code>std::cin</code>和<code>std::getline</code>解析数据的方式不同</p>
<ul>
<li><code>std::cin &gt;&gt;</code><br>
在读取完输入后，<strong>会把换行符（按回车键产生的 <code>\n</code>）留在输入缓冲区里</strong>，不会自动去掉。</li>
<li><code>std::getline()</code><br>
会自动读取并<strong>丢弃掉行尾的换行符</strong>，也就是说，它会把换行符从缓冲区中清除掉。</li>
</ul>
<p><strong>因此</strong></p>
<ul>
<li><code>getline()</code>和<code>std::cin()</code>尽量不要一起使用</li>
</ul>
<h2 id="4-Containers">4. Containers</h2>
<h3 id="4-1-What-is-the-STL">4.1 What is the STL?</h3>
<p>STL: Standard <strong>Template</strong> Library</p>
<h4 id="4-1-1-What-are-templates">4.1.1 What are templates?</h4>
<p>当我们遇到几个任务，十分相似，但是差别是需要存储不同类型的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntVecor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleVector</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringVector</span></span><br></pre></td></tr></table></figure>
<p>如果我们有几百上千种类型呢？难道要一个一个写出来吗？因此引出<strong>模板</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">double</span>&gt; v2;</span><br><span class="line">vector&lt;string&gt; v3;</span><br></pre></td></tr></table></figure>
<p><strong>所有的STL容器都是模板</strong></p>
<h4 id="4-1-2-Containers">4.1.2 Containers</h4>
<p>如何保存一系列元素</p>
<h5 id="4-1-2-1-Sequence-Containers">4.1.2.1 Sequence Containers</h5>
<p>序列式容器用于保存一些列线性元素</p>
<ul>
<li><strong>std::vector</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">vec[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	std::cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips</p>
<ol>
<li>如果可以，使用<strong>range-based for</strong>（基本范围的for循环）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	std::cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// range-based for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : vec) &#123;</span><br><span class="line">	std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>适用于所有可迭代容器，而不仅仅是<code>std::vector</code></p>
<ol start="2">
<li>如果可以，使用<strong>const auto&amp;</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;MassiveType&gt; vec &#123; ... &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : vec) ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// const auto&amp;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : v)</span><br></pre></td></tr></table></figure>
<p>避免了为每个元素创建潜在昂贵的副本</p>
<ol start="3">
<li>[]操作符不会进行边界检查</li>
</ol>
<p>假定现在又超过一百万个元素在一个vector中，想要在第一个地方添加一个元素，就需要将这一百万个元素全部向后移动一位，这很耗费时间，由此我们就引出了<strong>deque</strong></p>
<ul>
<li><strong>std::deque</strong> ：deque是双端队列，允许操作第一个或最后一个元素，对于vector来说，用的是空间中的一组内存，而对于deque，用的是空间中一组内存的一组内存，将整个元素分开了</li>
</ul>
<h5 id="4-1-2-2-Associative-Containers">4.1.2.2 Associative Containers</h5>
<p>关联式容器用于组织键值对元素</p>
<ul>
<li><strong>std::map</strong> 用一个key来匹配一个value，其中key是唯一的，value可以不唯一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m; <span class="comment">// 创建一个空map</span></span><br><span class="line"><span class="comment">// 将key为k，value为v的键值对添加到map中</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;k, v&#125;);</span><br><span class="line">m[k] = v;</span><br><span class="line">m.<span class="built_in">erase</span>(k); <span class="comment">// 移除key为k的键值对</span></span><br><span class="line"><span class="comment">// 检查k是否在map里</span></span><br><span class="line">m.<span class="built_in">count</span>(k)</span><br><span class="line">m.<span class="built_in">contains</span>(k) <span class="comment">// C++20</span></span><br><span class="line">m.<span class="built_in">empty</span>() <span class="comment">// 检查map是否为空</span></span><br><span class="line"><span class="comment">// 将key为k的value重写</span></span><br><span class="line"><span class="type">int</span> i = m[k];</span><br><span class="line">m[k] = i;</span><br></pre></td></tr></table></figure>
<p>当map存储的是一个键值对时，其也可以被看作为pair</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;K, V&gt;</span><br><span class="line">std::pair&lt;<span class="type">const</span> K, V&gt;</span><br></pre></td></tr></table></figure>
<p>此处K为常量，即K是不可以被修改的，在map中key也是不可以被修改的，所以此处不能变 <strong>range-based for</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> kv : map) &#123;</span><br><span class="line">	<span class="comment">// 此处就是把map当作pair来看，用的是first和second</span></span><br><span class="line">	std::string key = kv.first;</span><br><span class="line">	<span class="type">int</span> value = kv.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处map就是map</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : map) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map的底层原理即为<strong>红黑树</strong>，这也就意味着key必须要有<strong>操作符&lt;</strong>，比如<code>std::map&lt;std::ifstream, int&gt; map</code>在这里就是错误的，因为ifstream无法比较。</p>
<ul>
<li><strong>std::set</strong> set存储一组<strong>唯一</strong>的元素(没有values的std::map)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">char</span>&gt; s; <span class="comment">// 创建一个空set</span></span><br><span class="line">s.<span class="built_in">insert</span>(k); <span class="comment">// 将k添加到set中</span></span><br><span class="line">s.<span class="built_in">erase</span>(k); <span class="comment">// 移除set中的k</span></span><br><span class="line"><span class="comment">// 检查k是否在set里</span></span><br><span class="line">s.<span class="built_in">count</span>(k);</span><br><span class="line">s.<span class="built_in">contains</span>(k) <span class="comment">// C++20</span></span><br><span class="line">s.<span class="built_in">empty</span>() <span class="comment">// 检查set是否为空</span></span><br></pre></td></tr></table></figure>
<p>set是没有value的map set的底层原理也是红黑树，这同样意味着需要存在<strong>操作符&lt;</strong></p>
<ul>
<li><strong>std::unordered_map</strong> 和 <strong>std::unordered_set</strong> 容器与上文提到的没有什么差别，不同的是底层实现为<strong>哈希表</strong>，通过哈希函数，将其<strong>转变为无序的</strong></li>
<li>为什么使用无序？ 更平均的负载因子，当负载因子过高时，允许rehash</li>
</ul>
<ol>
<li>通常来说，<code>unordered_map</code>要快于<code>map</code></li>
<li>但<code>unordered_map</code>要用更多的内存</li>
<li>若<code>key</code>不存在<strong>操作符&lt;</strong>，使用<code>unordered_map</code></li>
<li>若必须要从中挑一个，<code>unordered_map</code>会更安全</li>
</ol>
<h2 id="5-Iterators">5. Iterators</h2>
<h3 id="5-1-Iterator基础">5.1 Iterator基础</h3>
<p>在上文提到的range-based for中，这是如何实现的？容器与迭代器协同工作就构成了迭代，迭代器存在三个操作</p>
<ul>
<li>
<p>获取一个元素</p>
</li>
<li>
<p>向前移动一个元素</p>
</li>
<li>
<p>检查整个元素是否已经遍历完成 容器存在两个接口</p>
</li>
<li>
<p><code>container.begin()</code>获取<em>第一个元素</em>迭代器</p>
</li>
<li>
<p><code>container.end()</code>获取<strong>最后一个元素的后一个元素</strong>的迭代器，它永远不会指向最后一个元素，一定会指向最后一个元素的后一个元素，因为若此容器为空，<code>c.begin() == c.end()</code>就会为真，综上，当我们写下</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : s) &#123;</span><br><span class="line">	std::cout &lt;&lt; elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是写下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">	<span class="keyword">auto</span> elem = *it;</span><br><span class="line">	std::cout &lt;&lt; elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么使用<code>++it</code>而不是<code>it++</code> ？</li>
</ul>
<p>​	<code>it++</code>会避免生成不必要的复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prefix ++it</span></span><br><span class="line">Iterator&amp; <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Postfix it++</span></span><br><span class="line">Iterator <span class="keyword">operator</span>++();</span><br></pre></td></tr></table></figure>
<h3 id="5-2-Iterator-Types">5.2 Iterator Types</h3>
<p>对于迭代器来说，不止有一个一个增加的迭代，还存在许多其他操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--it; <span class="comment">// 向前一位</span></span><br><span class="line">*it = elem; <span class="comment">// 修改此处的值</span></span><br><span class="line">it += n; <span class="comment">// 向前n位</span></span><br><span class="line">it1 &lt; it2; <span class="comment">// 判断it1是否在it2前面</span></span><br></pre></td></tr></table></figure>
<p>若元素在结构体当中，可以用<code>-&gt;</code>来访问元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Bibble</span> &#123;</span><br><span class="line">	<span class="type">int</span> zarf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;Bibble&gt; v &#123;...&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="type">int</span> m = (*it).zarf;</span><br><span class="line"><span class="type">int</span> m = it-&gt;zarf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO迭代器</span></span><br><span class="line"><span class="keyword">auto</span> elem = *it <span class="comment">// 访问元素</span></span><br><span class="line">*it = elem; <span class="comment">// 写入元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向前迭代器</span></span><br><span class="line">it1 == it2；</span><br><span class="line">++it1 == ++it2；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向迭代器</span></span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">end</span>();</span><br><span class="line">--it;</span><br><span class="line"><span class="keyword">auto</span>&amp; elem = *it; <span class="comment">// 获取最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//随机访问迭代器</span></span><br><span class="line"><span class="keyword">auto</span> it2 = it + <span class="number">5</span>; <span class="comment">// 向前五个</span></span><br><span class="line"><span class="keyword">auto</span> it3 = it2 - <span class="number">2</span>; <span class="comment">// 向后两个</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-Pointers-and-Memory">5.3 Pointers and Memory</h3>
<p>一个<strong>迭代器</strong>指向一个<strong>容器元素</strong>，一个<strong>指针</strong>指向任何<strong>对象</strong></p>
<h4 id="5-3-1-Memory基础">5.3.1 Memory基础</h4>
<ul>
<li>每个变量都存放在内存中的某个地方</li>
<li>所有地方都可以被一个地址来表示</li>
<li>地址用字节寻址法，每个字节都从0开始</li>
<li>1 Byte = 8 bits</li>
<li>一个对象的地址是用此对象最小地址来表示的，对于一个整数类型x来说，它在内存中占四个字节，假设为0x10、0x11、0x12、0x13，那么此时x的地址就是0x10</li>
</ul>
<h4 id="5-3-2-变量地址表示方法">5.3.2 变量地址表示方法</h4>
<p><strong>指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">106</span>;</span><br><span class="line"><span class="type">int</span>* px = &amp;x; <span class="comment">// int*为一个整数指针 &amp;为取地址操作符</span></span><br><span class="line"></span><br><span class="line">x <span class="comment">// 106</span></span><br><span class="line">*px <span class="comment">// 106</span></span><br><span class="line">px <span class="comment">// 0x50527c</span></span><br></pre></td></tr></table></figure>
<p>对于不同的对象，有不同的指针表示方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">106</span>;</span><br><span class="line"><span class="type">int</span>* px = &amp;x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line">StanfordID id &#123;<span class="string">&quot;jtrb&quot;</span>&#125;;</span><br><span class="line">StanfordID* p = &amp;id;</span><br><span class="line"><span class="keyword">auto</span> name = p -&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;* p = &amp;v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector []表示法</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>* arr = &amp;v[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>对于vector来说，其在内存中是以一块内存表示的，故我们可以使用<strong>指针运算</strong>来表示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>* arr = &amp;v[<span class="number">0</span>];</span><br><span class="line">arr += <span class="number">1</span>; <span class="comment">// index = 1</span></span><br><span class="line">++arr; <span class="comment">// index = 2</span></span><br><span class="line">arr += <span class="number">2</span>; <span class="comment">// index = 4</span></span><br><span class="line">arr == &amp;v[<span class="number">4</span>]; <span class="comment">// 取index为4的值</span></span><br></pre></td></tr></table></figure>
<p><strong>迭代器</strong>与<strong>指针</strong>有相同的接口</p>
<h2 id="6-Classes">6. Classes</h2>
<h3 id="6-1-类基础">6.1 类基础</h3>
<ol>
<li>为什么使用类？
<ul>
<li>C没有对象</li>
<li>不能在操作数据的时候封装数据与函数</li>
<li>无法使用面向对象编程范式</li>
</ul>
</li>
<li>什么是面向对象编程？
<ul>
<li>面向对象所有内容都是围绕对象来实现的</li>
<li>专注于设计与实现类</li>
<li>类是由用户定义的 <strong>容器都是STL定义的类</strong></li>
</ul>
</li>
</ol>
<h3 id="6-2-结构体与类的区别">6.2 结构体与类的区别</h3>
<p><strong>结构体是不受限制的类</strong>，对于结构体来说，其所定义的所有<code>fields</code>都是<code>public</code>的，这也就意味着它们可以被用户随意更改 对于类，其存在<code>public</code> <code>private</code>，用户只能访问<code>public</code>的对象</p>
<h3 id="6-3-类语法">6.3 类语法</h3>
<h4 id="6-3-1-头文件与源文件的区别">6.3.1 头文件与源文件的区别</h4>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Header File(.h)</th>
<th style="text-align:left">Source File(.cpp)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">目的</td>
<td style="text-align:left">定义接口</td>
<td style="text-align:left">实现函数</td>
</tr>
<tr>
<td style="text-align:left">包括内容</td>
<td style="text-align:left">函数原型、类声明、类型定义、宏、常数</td>
<td style="text-align:left">函数具体实现内容，执行代码</td>
</tr>
<tr>
<td style="text-align:left">访问</td>
<td style="text-align:left">与源文件分享</td>
<td style="text-align:left">被编译</td>
</tr>
<tr>
<td style="text-align:left">举例</td>
<td style="text-align:left"><code>void someFunction();</code></td>
<td style="text-align:left"><code>void someFunction()&#123;&#125;;</code></td>
</tr>
</tbody>
</table>
<h4 id="6-3-2-设计类">6.3.2 设计类</h4>
<ul>
<li>构造函数</li>
<li>私有函数/变量</li>
<li>公共函数</li>
<li>析构函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h file</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StanfordID</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::string name;</span><br><span class="line">	std::string sunet;</span><br><span class="line">	<span class="type">int</span> idNumber;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StanfordID</span>(std::string name, std::string sunet, <span class="type">int</span> idNumber); <span class="comment">// Constructor</span></span><br><span class="line">	<span class="comment">// method</span></span><br><span class="line">	<span class="function">std::string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">getSunet</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getID</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp file</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StanfordID.h&quot;</span> <span class="comment">// 包含头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用namespace就像std::一样</span></span><br><span class="line">StanfordID::<span class="built_in">StanfordID</span>(std::string name, std::string sunet, <span class="type">int</span> idNumber) &#123;</span><br><span class="line">	<span class="keyword">this</span> -&gt; name = name; <span class="comment">// 使用this关键字来表示现在具体是哪个值</span></span><br><span class="line">	<span class="keyword">this</span> -&gt; sunet = sunet;</span><br><span class="line">	<span class="comment">// 可以检查是否有效</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> -&gt; idNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span> -&gt; idNumber = idNumber;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uniform initialization(C++11)</span></span><br><span class="line">StanfordID::<span class="built_in">StanfordID</span>(std::string name, std::string sunet, <span class="type">int</span> idNumber) : name&#123;name&#125;, sunet&#123;sunet&#125;, idNumber&#123;idNumber&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现方法</span></span><br><span class="line"><span class="function">std::string <span class="title">StanfordID::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">StanfordID::getSunet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;sunet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StanfordID::getID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;idNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StanfordID::setName</span><span class="params">(std::string name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StanfordID::setSunet</span><span class="params">(std::string sunet)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;sunet = sunet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StanfordID::setID</span><span class="params">(<span class="type">int</span> idNumber)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (idNumber &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;idNumber = idNumber;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destructor</span></span><br><span class="line">StanfordID::~<span class="built_in">StanfordID</span>() &#123;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于析构函数来说，它是为了释放我们在空间中使用的内存，但当我们<code>new</code>一个新对象时，它会自动帮我们释放的，尽管如此，这依旧很重要</p>
<h3 id="6-4-Inheritance（继承）">6.4 Inheritance（继承）</h3>
<h4 id="6-4-1-继承介绍">6.4.1 继承介绍</h4>
<ul>
<li>多态性：不同的对象有可能会使用相同的接口</li>
<li>可扩展性：继承允许扩大类来创造子类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h file</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 虚拟函数</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123; <span class="comment">// :继承</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> _radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Circle</span>(<span class="type">double</span> radius): _radius&#123;radius&#125; &#123;&#125;; <span class="comment">// 构造函数 uniform initialization</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3.14</span> * _radius * _radius;</span><br><span class="line">	&#125; <span class="comment">// 重写 area()函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">// constructor</span></span><br><span class="line">	<span class="built_in">Rectangle</span>(<span class="type">double</span> height, <span class="type">double</span> width): _height&#123;height&#125;,_width&#123;width&#125;&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _width * _height;&#125;<span class="keyword">private</span>:<span class="type">double</span> _width,_height;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="6-4-2-钻石问题">6.4.2 钻石问题</h4>
<p><img src="/images/CS-106L-3.png" alt></p>
<p>现在<code>Employee</code>和<code>Student</code>都继承自<code>Person</code>，<code>SectionLeader</code>有同时继承<code>Employee</code>和<code>Student</code>，该怎么处理？</p>
<p><strong>解决这个问题的方法是让<code>Employee</code>和<code>Student</code> 以 虚拟方式 继承自 <code>Person</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里是虚拟继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> Person &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	std::string idNumber;</span><br><span class="line">	std::string major;</span><br><span class="line">	std::string advisor;</span><br><span class="line">	<span class="type">uint16_t</span> year;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name, …);</span><br><span class="line">	<span class="function">std::string <span class="title">getIdNumber</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">getMajor</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">uint16_t</span> <span class="title">getYear</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setYear</span><span class="params">(<span class="type">uint16_t</span> year)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setMajor</span><span class="params">(<span class="type">const</span> std::string&amp; major)</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">getAdvisor</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAdvisor</span><span class="params">(<span class="type">const</span> std::string&amp; advisor)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是虚拟继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> Person &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">double</span> salary;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Employee</span>(<span class="type">const</span> std::string&amp; name);</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string <span class="title">getRole</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getSalary</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setSalary</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Employee</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>==<strong>在虚继承下，构造虚基类的责任在“最终派生类”，而不是中间的派生类。</strong>==</p>
<p>如何理解？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name) &#123; std::cout &lt;&lt; <span class="string">&quot;Person: &quot;</span> &lt;&lt; name &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Employee</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">Person</span>(name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Employee&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name) : <span class="built_in">Person</span>(name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Student&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SectionLeader</span> : <span class="keyword">public</span> Employee, <span class="keyword">public</span> Student &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SectionLeader</span>(<span class="type">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">Person</span>(name), <span class="built_in">Employee</span>(name), <span class="built_in">Student</span>(name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;SectionLeader&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意这里：<code>Employee(name)</code> 和 <code>Student(name)</code> 都调用了 <code>Person(name)</code>，<strong>但其实它们的那个 <code>Person(name)</code> 调用会被忽略</strong>！</p>
<p>因为 <code>Person</code> 是虚基类（<code>virtual public Person</code>），所以 <strong>只有最底层的 <code>SectionLeader</code> 构造函数的 <code>Person(name)</code> 会生效</strong>。</p>
<p>因此：<strong>在虚继承下，构造虚基类的责任在“最终派生类”，而不是中间的派生类。</strong></p>
<h2 id="7-Template-Classes">7. Template Classes</h2>
<h3 id="7-1-预处理器与宏定义">7.1 预处理器与宏定义</h3>
<p>在创建我们自己的vector的时候，会遇到对不同的类型写不同的代码的情况，但它们之间的区别又很小，只有一个类型的差别，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntVector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span>&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; elem)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span>* elems;</span><br><span class="line">	<span class="type">size_t</span> logical_size;</span><br><span class="line">	<span class="type">size_t</span> array_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleVector</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringVector</span></span><br></pre></td></tr></table></figure>
<p>对于这种情况，我们引出了预处理器与宏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GENERATE_VECTOR(MY_TYPE)</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">MY_TYPE</span>##Vector &#123; </span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">		<span class="function">MY_TYPE&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span></span>; </span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> MY_TYPE&amp; elem)</span></span>; </span><br><span class="line">	<span class="keyword">private</span>: </span><br><span class="line">		MY_TYPE* elems; </span><br><span class="line">		<span class="type">size_t</span> logical_size; </span><br><span class="line">		<span class="type">size_t</span> array_size; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">GENERATE_VECTOR</span>(<span class="type">int</span>)</span><br><span class="line"><span class="type">int</span> Vector v1;</span><br><span class="line">v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>预处理器允许其在编译之前运行 通过这种方式，允许我们创建不同类型的vector 但对于这种方式，也会存在其缺点</p>
<ul>
<li>类C语言的语法</li>
<li>很难做类型检查</li>
<li>有时会忘了做宏定义</li>
</ul>
<p>因此，继续引出<strong>Templates</strong></p>
<h3 id="7-2-Templates">7.2 Templates</h3>
<p>模板允许自动生成代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 模板声明 T会自己替换类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; elem)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* elems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于特定类型的模板，我们称其为<strong>Template Instantiation</strong>，以下均为模板实例化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SizeTemplate</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> B&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoolTemplate</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> N&gt;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-1-一些模板的怪癖">7.2.1 一些模板的怪癖</h4>
<ol>
<li>在<code>.cpp</code>文件中必须包含<code>template&lt; &gt;</code></li>
<li><code>.h</code>必须在底部包含<code>.cpp</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Vector.cpp&quot;</span> <span class="comment">// 怪癖2 必须包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 怪癖1 显式写出来</span></span><br><span class="line">T&amp; Vetor&lt;T&gt;::<span class="built_in">at</span>(<span class="type">size_t</span> i) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>typename</code>与<code>class</code>是一样的</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">struct</span> <span class="title class_">pair</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt; <span class="keyword">struct</span> <span class="title class_">pair</span>;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-Const-Correctness">7.3 Const Correctness</h3>
<p>当我们书写以下函数时，编译器会给出错误<code>No such method size!</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVec</span><span class="params">(<span class="type">const</span> Vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		std::cout &lt;&lt; v.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但我们明明在之前就已经实现了<code>size</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[] (<span class="type">size_t</span> index);</span><br><span class="line">	<span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; elem)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>问题在于</p>
<ul>
<li>对于v来说传递的是个常量，编译器不希望修改v</li>
<li>编译器不确定<code>size</code>是否会修改v</li>
<li>因为成员函数是有可能会修改v的，因此需要<strong>在成员函数后面加上<code>const</code>标识符，以告诉编译器，我确保此方法不会修改对象</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[] (<span class="type">size_t</span> index);</span><br><span class="line">	<span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; elem)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于<code>.cpp</code>文件也应该加上<code>const</code>标识符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">size_t</span> Vector&lt;T&gt;::<span class="built_in">size</span>() <span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> logical_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-3-1-Const-interface">7.3.1 Const interface</h4>
<ul>
<li>对象被标记为const后只能使用const接口</li>
<li>const接口是作为对象中的一个常量函数</li>
</ul>
<h4 id="7-3-2-Const-Cast">7.3.2 Const Cast</h4>
<p>对于<code>T&amp; at(size_t index) const;</code>来说存在两个错误</p>
<ol>
<li><code>const</code> 成员函数仍然可以修改元素
<ul>
<li><code>const</code> 修饰的是成员函数，表示该函数<strong>不能修改对象的成员变量</strong>（<code>mutable</code> 除外）。</li>
<li>如果返回值类型是 <code>T&amp;</code>，即使成员函数是 <code>const</code>，<strong>调用者仍然可以通过这个引用修改容器的元素。</strong></li>
<li>这样会破坏 <code>const</code> 对象“只读”的语义</li>
</ul>
</li>
</ol>
<p>​	<strong>改进方法：</strong><br>
​	在 <code>const</code> 成员函数中返回 <strong>const 引用</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>非 <code>const</code> 对象无法通过 <code>at()</code> 修改元素</p>
<ul>
<li>
<p>如果只保留 <code>const T&amp; at(...) const</code> 版本，那么无论对象是否是 <code>const</code>，返回值都是 <code>const</code> 引用，元素将永远不能修改。</p>
<p>这会限制非 <code>const</code> 对象的正常使用。</p>
</li>
</ul>
<p><strong>改进方法：</strong><br>
重载 <code>at()</code> 函数：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 非 const 对象调用，返回可写引用</span></span><br><span class="line">    <span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 对象调用，返回只读引用</span></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但如果我们有许多函数要对常量与非常量进行运算，那每个函数就要写两遍，这过于冗余了，因此我们引出<strong>casting</strong></p>
<ul>
<li>casting 将一个类型强制转换为另一个类型</li>
<li><code>const_cast</code> 将非const强转为const <code>const_cast&lt;Vector&lt;T&gt;&amp;&gt;(*this).findElement(value);</code></li>
<li><code>const_cast</code>将非const强转为const</li>
<li><code>Vector&lt;T&gt;&amp;</code>非const引用</li>
<li><code>*this</code>解引用<code>const Vector&lt;T&gt;*</code></li>
<li><code>findElement</code>非const版本的<code>findElement()</code> 什么时候使用<strong>const_cast</strong>？ <strong>最好不要</strong></li>
</ul>
<h2 id="8-Template-Functions">8. Template Functions</h2>
<h3 id="8-1-Template-Functions">8.1 Template Functions</h3>
<h4 id="8-1-1-三元运算符">8.1.1 三元运算符</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> a &lt; b ? a : b;</span><br></pre></td></tr></table></figure>
<p>若 a &lt; b 则返回 a 反之返回 b 当我们想将不同的类型进行上述比较，按之前的方法可能需要些若干个函数，分别表示不同的类型，但现在我们可以使用模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，可以写出引用类型，防止复制一份额外的，占用内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-1-2-调用模板函数">8.1.2 调用模板函数</h4>
<ul>
<li>explicit instantiation（显式实例化）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>&lt;<span class="type">int</span>&gt;(<span class="number">106</span>, <span class="number">107</span>);</span><br><span class="line"><span class="built_in">min</span>&lt;<span class="type">double</span>&gt;(<span class="number">1.2</span>, <span class="number">3.4</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>implicit instantiation（隐式实例化）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(<span class="number">106</span>, <span class="number">107</span>);</span><br><span class="line"><span class="built_in">min</span>(<span class="number">1.2</span>, <span class="number">3.4</span>);</span><br></pre></td></tr></table></figure>
<p>编译器会自己调用类型，有点像之前学到的<code>auto</code>关键字 若给出<code>min(106, 3.14)</code>则无法编译，解决方法为改变函数签名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-Concepts">8.2 Concepts</h3>
<p>编译器发现错误只会在实例化之后，这也就是说，有些事物可以被实例化，但无法被比较，此时编译器会正常实例化，但无法比较，由此，如何才能在实例化之前发现错误（无法被比较）？</p>
<h4 id="Introducing-C-concepts">Introducing C++ concepts</h4>
<p>创建Comparable concept</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Comparable = <span class="built_in">requires</span>(<span class="type">const</span> T a, <span class="type">const</span> T b) &#123;</span><br><span class="line">	&#123;a &lt; b&#125; -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>concept: a named set of constraints</li>
<li>requires: 提供两个参数</li>
<li><code>&#123;a &lt; b&#125;</code>(constraint): 任何在大括号内的东西都必须被无错误地编译</li>
<li><code>std::convertible_to&lt;bool&gt;</code>(constraint): 结果必须为布尔值 此时，就可以避免无法被比较的错误了</li>
</ul>
<p>使用Comparable concept</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">requires</span> Comparable&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简短写法</span></span><br><span class="line"><span class="keyword">template</span> &lt;Comparable T&gt;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-Variadic-Templates">8.3 Variadic Templates</h3>
<p>如果我们想在一个函数里面接受更多的参数，应该怎么做，简单的想法是重写许多个函数，让编译器自己寻找该用哪一个，这显然过于冗余</p>
<p><strong>Templates + recursion</strong>（模板 + 递归）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base case  不需要递归</span></span><br><span class="line"><span class="keyword">template</span> &lt;Comparable T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; v)</span> </span>&#123;<span class="keyword">return</span> v;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recrusive case 需要递归</span></span><br><span class="line"><span class="keyword">template</span> &lt;Comparable T, Comparable... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; v, <span class="type">const</span> Args&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> m = <span class="built_in">min</span>(args...);</span><br><span class="line">	<span class="keyword">return</span> v &lt; m ? v : m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Comparable... Args</code> <strong>Variadic template</strong>匹配0或更多个类型</li>
<li><code>const Args&amp;</code> <strong>Parameter pack</strong>匹配0或更多个参数</li>
<li><code>min(args...)</code> 替换为实际参数</li>
</ul>
<h3 id="8-4-Template-Metaprogramming">8.4 Template Metaprogramming</h3>
<p><strong>TMP is Turing complete</strong></p>
<p>如何让我们得到既可以在编译时运行又有可读性的代码呢？</p>
<p>使用<strong>constexpr/consteval</strong>(C++20)</p>
<p>constexpr: 尝试在编译时运行此段代码</p>
<p>consteval: 必须在编译时运行此段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">factorial</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">size_t</span> <span class="title">factorial</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n - <span class="number">1</span>) + <span class="built_in">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> f = <span class="built_in">fib</span>(<span class="number">10</span>); <span class="comment">// 在编译期算出 55</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果用 consteval：</span></span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? n : <span class="built_in">fib</span>(n<span class="number">-1</span>) + <span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">fib</span>(<span class="number">10</span>); <span class="comment">// ✅ 必须编译期算出来</span></span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    std::cin &gt;&gt; y;</span><br><span class="line">    <span class="built_in">fib</span>(y); <span class="comment">// ❌ 错误，必须在编译期有结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Metaprogramming 的意义</strong>：让程序在 <strong>编译时就能运算/生成代码/检查错误</strong>。</p>
<p><strong>为什么要编译时运行</strong>：</p>
<ol>
<li>提升性能（运行时不用算）</li>
<li>自动生成高效的代码（矩阵/容器优化等）</li>
<li>提前发现错误（静态检查）</li>
</ol>
<h2 id="9-Functions-and-Lambdas">9. Functions and Lambdas</h2>
<h3 id="9-1-Functions-and-Lambdas">9.1 Functions and Lambdas</h3>
<h4 id="9-1-1-传递函数">9.1.1 传递函数</h4>
<p>有时会想把一个布尔函数作为查找一个东西的条件，我们在此称其为<strong>predicates</strong>那么如何优雅的将此条件加入到函数中呢，简单想法为作为函数中的一个参数来实现，问题在于其类型是什么，以<code>find_if()</code>为例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> Pred&gt;</span><br><span class="line"><span class="function">It <span class="title">find_if</span><span class="params">(It first, It last, Pred pred)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = first; it != last; ++it) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">pred</span>(*it)) <span class="keyword">return</span> it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此我们对于predicates的类型作为<strong>typename</strong>，编译器会自己帮我们找其类型具体是什么的。在函数内也传递了此条件，运用了此条件 旁注，Pred的类型具体是什么？ 在C++中，这可以作为一个<strong>函数指针</strong>，用于指向一个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pred = <span class="built_in">bool</span>(*)(<span class="type">int</span>);</span><br><span class="line">Pred = <span class="built_in">bool</span>(*)(<span class="type">char</span>);</span><br></pre></td></tr></table></figure>
<p>但有时候又会遇见在条件中不止一个参数的情况，比如<code>bool isLessThan(int elem, int n)</code>在这种情况，我们就无法在其他函数中使用此函数，因为要在其他函数使用此函数，只能传递一个参数，由此引出<strong>Lambda Functions</strong></p>
<h4 id="9-1-2-Lambda函数">9.1.2 Lambda函数</h4>
<p>Lambda函数允许我们在使用一个参数的情况下也依然可以比较多个参数之间的值，举例来说，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lessThanN = [n](<span class="type">int</span> x) &#123;</span><br><span class="line">	<span class="keyword">return</span> x &lt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们实际上只传递了一个参数x，lambda函数允许出现在其他函数的参数中</p>
<h4 id="9-1-3-Functor-仿函数">9.1.3 Functor(仿函数)</h4>
<p>一个<strong>扮演着函数的对象</strong>，由<code>operator()</code>定义的对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::greater &#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a &gt; b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::greater&lt;<span class="type">int</span>&gt; g;</span><br><span class="line"><span class="built_in">g</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>由于仿函数是一个对象，所以其存在state（状态）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">my_functor</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a * value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line">my_functor f;</span><br><span class="line">f.value = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="9-1-4-仿函数与Lambda函数之间的关系">9.1.4 仿函数与Lambda函数之间的关系</h4>
<p>当我们写一个Lambda函数时，实际上就是在用仿函数来写，例如以下<strong>两函数表达的是同一个意思</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数1</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lessThanN = [n](<span class="type">int</span> x)</span><br><span class="line">&#123; <span class="keyword">return</span> x &lt; n; &#125;;</span><br><span class="line"><span class="built_in">find_if</span>(begin, end, lessThanN);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__lambda_6_18</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> x &lt; n; &#125;</span><br><span class="line">	__lambda_6_18(<span class="type">int</span>&amp; _n) : n&#123;_n&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lessThanN = __lambda_6_18&#123;n&#125;;</span><br><span class="line"><span class="built_in">find_if</span>(begin, end, lessThanN);</span><br></pre></td></tr></table></figure>
<h3 id="9-2-Algorithms">9.2 Algorithms</h3>
<p><code>&lt;algorithm&gt;</code>是一个模板函数的集合</p>
<h3 id="9-3-Ranges-and-Views">9.3 Ranges and Views</h3>
<h4 id="9-3-1-Ranges">9.3.1 Ranges</h4>
<p>Ranges是一个STL的新版本 定义：range是任何拥有<code>begin</code>和<code>end</code>的东西 这意味着许多可以迭代的数据结构都存在ranges</p>
<h4 id="9-3-2-Views">9.3.2 Views</h4>
<p>Views是一种组合算法的方法</p>
<p>定义：惰性的适配另一个range的range</p>
<p>若我们用现在的STL来写代码，可能会是这样的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">char</span>&gt; v = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">// Filter -- Get only the vowels</span></span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; f;</span><br><span class="line">std::<span class="built_in">copy_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(f), isVowel);</span><br><span class="line"><span class="comment">// Transform -- Convert to uppercase</span></span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; t;</span><br><span class="line">std::<span class="built_in">transform</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(t), toupper);</span><br><span class="line"><span class="comment">// &#123; &#x27;A&#x27;, &#x27;E&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p>但使用veiws来写，就会简单很多</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">char</span>&gt; letters = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e’&#125;;</span></span><br><span class="line"><span class="string">auto f = std::ranges::views::filter(letters, isVowel);</span></span><br><span class="line"><span class="string">auto t = std::ranges::views::transform(f, toupper);</span></span><br><span class="line"><span class="string">auto vowelUpper = std::ranges::to&lt;std::vector&lt;char&gt;&gt;(t);</span></span><br></pre></td></tr></table></figure>
<p>同时还可以使用<code>|</code>链式操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">char</span>&gt; letters = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">char</span>&gt; upperVowel = letters</span><br><span class="line">| std::ranges::views::<span class="built_in">filter</span>(isVowel)</span><br><span class="line">| std::ranges::views::<span class="built_in">transform</span>(toupper)</span><br><span class="line">| std::ranges::to&lt;std::vector&lt;<span class="type">char</span>&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>使用ranges/views的优缺点 优点</p>
<ul>
<li>不用担心迭代器</li>
<li>更好的错误消息提示</li>
<li>可读性更高、函数化更好的语法 缺点</li>
<li>太新了（C++20开始），很少人了解</li>
<li>缺乏编译器支持</li>
<li>与手工编码版本相比的性能缺失</li>
</ul>
<h2 id="10-Operator-Overloading">10. Operator Overloading</h2>
<h3 id="10-1-Member-overloading">10.1 Member overloading</h3>
<p>当我们想要比较我们自己创建的类的时候，常常会因为此类无法被比较而失败，但C++允许我们自己<strong>重载操作符</strong>，以帮助我们比较两个类，就像我们之前学习的<code>StanfordID</code>类，就可以对其操作符进行重载，具体怎么做？</p>
<ul>
<li>就像我们在类中声明函数一样，我们可以以声明函数的方式声明操作符</li>
<li>当我们对我们创建的对象使用操作符时，这代表在执行自定义的函数或操作符</li>
<li>就像函数重载一样，当我们给了一样的名字，它就会重写操作符的行为，编译器自己会找到该用哪个的 因此，我们的<code>StanfordID</code>的<code>小于操作符</code>可以写成</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> StanfordID::<span class="keyword">operator</span>&lt; (<span class="type">const</span> StanfordID&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> idNumber &lt; other.<span class="built_in">getIdNumber</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哪些操作符不能重载？<br>
:: ? . .* sizeof() typeid() cast()</p>
<h3 id="10-2-Non-member-overloading（非成员函数重载）">10.2 Non-member overloading（非成员函数重载）</h3>
<p>上文提到的是<strong>member overloading</strong>，不止这种方法，在C++中更被人们所喜欢和应用的是<strong>Non-member overloading</strong>，为什么？</p>
<ol>
<li>允许(left-hand-side)左边是非类类型(non-class type)</li>
<li>允许重载我们没有掌控的类的运算符，比如我们可以将<code>StanfordID</code>与其他类进行比较</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Non-member</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> StanfordID&amp; lhs, <span class="type">const</span> StanfordID&amp; rhs);</span><br><span class="line"><span class="comment">// member</span></span><br><span class="line"><span class="type">bool</span> StanfordID::<span class="keyword">operator</span>&lt; (<span class="type">const</span> StanfordID&amp; rhs) <span class="type">const</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-3-friend">10.3 <code>friend</code></h3>
<p><code>friend</code>关键字允许non-member函数或non-member类访问其他类中private里的值 <code>friend</code>应该写在<code>.h</code>文件中显式写出来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h file</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StanfordID</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string name;</span><br><span class="line">std::string sunet;</span><br><span class="line"><span class="type">int</span> idNumber;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// constructor for our StudentID</span></span><br><span class="line"><span class="built_in">StanfordID</span>(std::string name, std::string sunet, <span class="type">int</span> idNumber);</span><br><span class="line">... </span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> StanfordID&amp; lhs, <span class="type">const</span> StanfordID&amp; rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp file</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> StanfordID.h</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> StanfordID&amp; lhs, <span class="type">const</span> StanfordID&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.idNumber &lt; rhs.idNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运算符允许传递函数不存在的类型</strong></p>
<ul>
<li>operator overloading解锁了我们定义对象新的功能和意义</li>
<li>运算符应该有意义，传递一些函数并不关乎类型本身</li>
<li>仅在需要的时候overload，比如不需要使用IO流的时候就不需要重写<code>&lt;&lt;</code>或<code>&gt;&gt;</code></li>
</ul>
<h2 id="11-Special-Member-Functions">11. Special Member Functions</h2>
<h3 id="11-1-An-overview">11.1 An overview</h3>
<p>每次创建类的新的实例时都会调用<strong>构造函数</strong>，而当它超出作用域时会调用<strong>析构函数</strong></p>
<p><strong>6种特殊成员函数</strong></p>
<p>​	这些函数只有在被调用时才会生成（在你显式定义任何函数之前）：</p>
<ul>
<li>
<p>默认构造函数: T()</p>
</li>
<li>
<p>构造函数: ~T()</p>
</li>
<li>
<p>拷贝构造函数: T(const T&amp;)</p>
</li>
<li>
<p>拷贝赋值运算符: T&amp; operator=(const T&amp;)</p>
</li>
<li>
<p>移动构造函数: T(T&amp;&amp;)</p>
</li>
<li>
<p>移动赋值运算符: T&amp; operator=(T&amp;&amp;)</p>
</li>
</ul>
<p>一般不需要自己写，因为这几种特殊成员函数会自动生成</p>
<h3 id="11-2-拷贝与拷贝赋值">11.2 拷贝与拷贝赋值</h3>
<p>我们可以用<strong>初始化器列表</strong>来一次性声明变量并使用所需的值对其进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;Vector&lt;T&gt;::<span class="built_in">Vector</span>() : _size(<span class="number">0</span>),_capacity(<span class="number">4</span>),_data(newT[_capacity]) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果变量是不可赋值类型呢？</strong></p>
<p>只有将初始化器列表写在public中才能初始化const变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> _constant;</span><br><span class="line">	<span class="type">int</span>&amp; _reference;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 	<span class="comment">// Only way to initialize const and reference members</span></span><br><span class="line"> 	<span class="built_in">MyClass</span>(<span class="type">int</span> value, <span class="type">int</span>&amp; ref) : _constant(value),</span><br><span class="line">	_reference(ref) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为什么我们应该重写Special Member Functions？</p>
<p>对于指针，<strong>成员逐个拷贝将会指向相同的已分配数据</strong>，而不是一个全新的拷贝！</p>
<p>此时对于其中一个指针所做的任何操作都会<strong>影响另一指针</strong></p>
<ul>
<li>很多时候，你可能需要创建一个不仅复制成员变量的副本。</li>
<li>深拷贝：一个与原始对象完全独立的副本独立</li>
<li>在这种情况下，你希望用自己的实现来覆盖默认的特殊成员函数！</li>
<li>在头文件中声明它们，并在 .cpp 中编写它们的实现，就像任何函数一样！</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝解决指针问题</span></span><br><span class="line">Vector&lt;T&gt;::<span class="built_in">Vector</span>(<span class="type">const</span> Vector&lt;T&gt;&amp; other)</span><br><span class="line">	: _size(other._size), _capacity(other._capacity), _data(<span class="keyword">new</span></span><br><span class="line">T[other._capacity]) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _size; ++i) &#123;</span><br><span class="line">		_data[i] = other._data[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-3-default和delete">11.3 default和delete</h3>
<h4 id="11-3-1-delete">11.3.1 delete</h4>
<p><img src="/images/CS-106L-4.png" alt></p>
<h4 id="11-3-2-default">11.3.2 default</h4>
<p><img src="/images/CS-106L-5.png" alt></p>
<h4 id="11-3-3-三大法则">11.3.3 三大法则</h4>
<ol>
<li>如果默认的特有成员函数能工作，不要定义自己的！</li>
</ol>
<p>​	我们应该只在编译器生成的默认函数无法工作时才定义新的特有成员函数。</p>
<ol start="2">
<li>
<p>如果你不需要构造函数或析构函数或拷贝赋值等。那么就简单不要使用它！</p>
<p>如果你的类依赖于已经实现了这些特殊成员函数的对象/类，那么就没有必要重新实现这个逻辑！</p>
</li>
<li>
<p>如果你需要一个自定义的析构函数，那么你可能还需要为你的类定义一个拷贝构造函数和一个拷贝赋值运算符</p>
</li>
</ol>
<h3 id="11-4-移动和移动赋值">11.4  移动和移动赋值</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringTable</span>(StringTable&amp;&amp; st) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    values = std::<span class="built_in">move</span>(st.values); <span class="comment">// 把 st 的资源“搬过来”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>noexcept：表示承诺函数不会抛异常</li>
</ul>
<p>如果移动构造 <strong>不是 <code>noexcept</code></strong>，那么 <code>vector</code> 就不敢用“移动”，只能退而求其次用“拷贝”，性能就会差很多</p>
<h2 id="12-Move-Semantics-移动语义">12. Move Semantics(移动语义)</h2>
<p>假设现在我们存在一个<code>Photo</code>类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Photo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Photo</span>(<span class="type">int</span> width, <span class="type">int</span> height);</span><br><span class="line">	<span class="built_in">Photo</span>(<span class="type">const</span> Photo&amp; other);</span><br><span class="line">	Photo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Photo&amp; other);</span><br><span class="line">	~<span class="built_in">Photo</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> width;</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line">	<span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor</span></span><br><span class="line">Photo::<span class="built_in">Photo</span>(<span class="type">int</span> width, <span class="type">int</span> height)</span><br><span class="line">	: <span class="built_in">width</span>(width)</span><br><span class="line">	, <span class="built_in">height</span>(height)</span><br><span class="line">	, <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[width * height])</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy Constructor</span></span><br><span class="line">Photo::<span class="built_in">Photo</span>(<span class="type">const</span> Photo&amp; other)</span><br><span class="line">	: <span class="built_in">width</span>(other.width)</span><br><span class="line">	, <span class="built_in">height</span>(other.height)</span><br><span class="line">	, <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[width * height])</span><br><span class="line">&#123;</span><br><span class="line">	std::<span class="built_in">copy</span>(other.data, other.data + width * height, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy Assignment</span></span><br><span class="line">Photo &amp;Photo::<span class="keyword">operator</span>=(<span class="type">const</span> Photo&amp; other) &#123;</span><br><span class="line">	<span class="comment">// Check for self assignment</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">delete</span>[] data; <span class="comment">// Clean up old pixels!</span></span><br><span class="line">	<span class="comment">// Copy over new pixels!</span></span><br><span class="line">	width = other.width;</span><br><span class="line">	height = other.height;</span><br><span class="line">	data = <span class="keyword">new</span> <span class="type">int</span>[width * height];</span><br><span class="line">	std::<span class="built_in">copy</span>(other.data, other.data + width * height, data);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line">Photo::~<span class="built_in">Photo</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span>[] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当此时已经存在一个<code>Photo</code>实例时，现在想要再得到一个相同的<code>Photo</code>时，第一时间可能会想到使用Copy复制一份，但可以有更好的方式不需要通过复制来实现——移动语义（<code>std::move()</code>）。使用这种方式可以直接指向原<code>Photo</code>而不用复制。但是，使用这种方式一定是安全的吗？如果我们未来还需要再使用这个对象，那此时<strong>原对象已经指向null了，就会出现空指针异常</strong>的情况。</p>
<h3 id="12-1-左值与右值">12.1 左值与右值</h3>
<p>关于左值与右值，上文已经有提过，在此需要对其加深理解。</p>
<ul>
<li>左值有明确的地址，右值则没有</li>
<li>一个左值可以出现在 = 的两边，右值只能出现在 = 的右侧</li>
</ul>
<ul>
<li>左值的生命周期在<strong>作用域</strong>结束</li>
<li>右值的生命周期在<strong>本行</strong>结束</li>
<li>左值是<strong>持续值</strong></li>
<li>右值是<strong>暂时值</strong> 对于引用类型来说，</li>
<li>左值：<code>Type&amp;</code></li>
<li>右值：<code>Type&amp;&amp;</code> <strong>重载<code>&amp;</code> <code>&amp;&amp;</code>以区分左值引用与右值引用</strong></li>
</ul>
<h3 id="12-2-移动语义">12.2 移动语义</h3>
<p>如果课件想讲“移动语义”，它应该写成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">uploadToInsta</span><span class="params">(Photo&amp;&amp; pic)</span></span>;  <span class="comment">// 接收右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Photo selfie = <span class="built_in">takePhoto</span>();</span><br><span class="line">    <span class="built_in">uploadToInsta</span>(std::<span class="built_in">move</span>(selfie));  <span class="comment">// 这里显式把 selfie 变成右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Move constructor
<ul>
<li><code>Type::(Type&amp;&amp; other)</code></li>
</ul>
</li>
<li>Move assignment operator
<ul>
<li><code>Type&amp; Type::operator=(Type&amp;&amp; other)</code> 一般来说，编译器会决定使用<code>&amp;</code>还是<code>&amp;&amp;</code>，但这一定是最有效率的吗？事实上，若我们知道一个值就是<strong>临时的</strong>，不妨主动使用移动语义。 要想显式删除移动语义，可以使用<code>= delete</code></li>
</ul>
</li>
</ul>
<h3 id="12-3-SMFs">12.3 SMFs</h3>
<p>目前为止，我们已经学习了许多Special Member Functions</p>
<p>但我们在写每个类的时候都需要把他们都写出来吗？</p>
<p><strong>不需要</strong></p>
<ul>
<li>Rule of Zero 若类不需要管理内存（或其他外部资源），编译器会创造有效的SMFs</li>
<li>Rule of Three 若类需要管理内存，必须定义<code>copy assignment/constructor</code>即<code>Destructor</code>、 <code>Copy Assignment</code> 和<code>Copy Constructor</code>，若不定义这些，编译器不会复制底层资源</li>
<li>Rule of Five 若定义了<code>copy assignment/constructor</code>即<code>Destructor</code> 、<code>Copy Assignment</code> 和<code>Copy Constructor</code>，则也应该定义<code>move constructor/assignment</code>，即<code>Move Assignment</code> 和<code>Move Constructor</code>，这不是必须的，但若不定义，则代码可能会在包含一些不必要的复制时<strong>变得缓慢</strong></li>
</ul>
<h2 id="13-std-optional-type-safety">13. <code>std::optional</code> &amp; type safety</h2>
<h3 id="13-1-Type-safety">13.1 Type safety</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">div_3</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">div_3</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这就是一个类型错误，函数需要的是<code>int</code>类型的参数，但给的是个<code>std::string</code>，编译器会给出错误，永远不会运行。</p>
<h3 id="13-2-std-optional-T">13.2 std::optional&lt; T &gt;</h3>
<p><code>std::optional</code>是一个模板类要么包含一个类型为T的值，要么什么也不包含，对于不包含的情况会表示为<strong>nullopt</strong>，nullopt是一个可以转换为任意可选类型的值的对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::optional&lt;<span class="type">int</span>&gt; num1 = &#123;&#125;; <span class="comment">//num1 does not have a value</span></span><br><span class="line">	num1 = <span class="number">1</span>; <span class="comment">//now it does!</span></span><br><span class="line">	num1 = std::<span class="literal">nullopt</span>; <span class="comment">//now it doesn&#x27;t anymore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::optional</code>含有以下接口</p>
<ul>
<li><code>.value()</code>: 返回包含的值或抛出<code>bad_optional_access</code>错误</li>
<li><code>.value_or(valueType val)</code>返回包含的值或默认值，参数 val</li>
<li><code>.has_value()</code> 如果包含值存在，则返回 true ，否则返回 false</li>
</ul>
<p>优点</p>
<ul>
<li>函数签名创建更多有意义的contracts</li>
<li>调用类函数时，会有更多保证和有效的行为</li>
</ul>
<p>缺点</p>
<ul>
<li>需要在任何地方使用<code>.value()</code></li>
<li>有可能存在<code>bad_optional_access</code></li>
<li>optionals会有未定义的行为（错误检查）</li>
<li>有很多情况我们想要<code>std::optional&lt;T&amp;&gt;</code>这个引用类型，但是C++并没有提供</li>
</ul>
<h3 id="13-3-总结">13.3 总结</h3>
<ul>
<li>可以保证程序在一个严格的类型检查下进行</li>
<li><code>std::optional</code>是一个工具可以用<code>.has_value()</code>来返回一个值或nothing</li>
<li>这个应用并不广泛并且慢，所以C++大多数数据结构并没有<code>optional</code></li>
<li>不仅在类中使用，在应用程序代码中也可以使用，并且是很推荐的。</li>
</ul>
<h2 id="14-RAII-Smart-Pointers-Building-Projects">14. RAII, Smart Pointers, Building Projects</h2>
<h3 id="14-1-RAII-Resource-Acquisition-Is-Initialization-资源获取即初始化">14.1 RAII(Resource Acquisition Is Initialization)资源获取即初始化</h3>
<h4 id="14-1-1-Exceptions">14.1.1 Exceptions</h4>
<ul>
<li>异常是一种处理错误的方法，用于抛出异常</li>
<li>异常是<strong>thrown（抛出）</strong></li>
<li>在非严重错误时捕获异常用于继续代码进行</li>
</ul>
<h4 id="13-1-2-RAII">13.1.2 RAII</h4>
<p>什么是RAII？</p>
<ul>
<li>一个类中所有使用的资源应该被构造函数所获取</li>
<li>一个类中所有使用的资源应该被析构函数所释放</li>
</ul>
<p>为什么使用RAII？</p>
<ul>
<li>通过遵守RAII政策，可以避免**half-valid(半有效)**状态</li>
<li>无论怎样，只要资源超出作用域，就会调用析构函数</li>
<li>资源/对象会立即运用当它们被创建</li>
</ul>
<h3 id="14-2-Smart-Pointers">14.2 Smart Pointers</h3>
<p>对于RAII for locks，我们会用<code>lock_guard</code>，这会创建一个对象用于在构造函数中获取所有资源，并在当操作完成后<strong>自动在对象析构函数中释放这些资源</strong>，而对于RAII for memory，我们也做同样的事情，只不过在这里我们称之为<strong>smart pointers</strong></p>
<ul>
<li><code>std::unique_ptr</code> 只属于这一个资源，不可以被复制</li>
<li><code>std::shared_ptr</code> 可以复制，当底层内存超出范围时，就会被破坏</li>
<li><code>std::weak_ptr</code> 一类旨在缓解循环依赖的指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要这么声明</span></span><br><span class="line">Node* n = <span class="keyword">new</span> Node;</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;T&gt; uniquePtr = std::<span class="built_in">make_unique</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;T&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">std::weak&lt;T&gt; wp = sharedPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样创建的对象在作用域结束时自动释放内存</span></span><br></pre></td></tr></table></figure>
<p><strong>一定要使用<code>std</code>来make smart pointer，而不是<code>std::unique_ptr&lt;T&gt; uniquePtr(new T());</code></strong></p>
<ul>
<li>如果不这么做，会分配两次内存，一次是为了声明一个指针，另一次是为了new一个对象</li>
<li>整个代码应该保持一个连续性，更易读</li>
</ul>
<h3 id="14-3-Building-C-Projects">14.3 Building C++ Projects</h3>
<h4 id="14-3-1-编译流程">14.3.1 编译流程</h4>
<p>编写一个C++代码后，它要被翻译为机器代码以使编译器识别 <code>g++ main.cpp -o main</code></p>
<h4 id="14-3-2-Make">14.3.2 Make</h4>
<p><strong>make</strong>是一个构建系统程序来帮助我们编译</p>
<ul>
<li>你可以规定编译器做什么</li>
<li>为了使用<strong>make</strong>需要有一个<strong>Makefile</strong></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compiler</span></span><br><span class="line">CXX = g++</span><br><span class="line"><span class="comment"># Compiler flags</span></span><br><span class="line">CXXFLAGS = -std=c++20</span><br><span class="line"><span class="comment"># Source files and target</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">TARGET = main</span><br><span class="line"><span class="comment"># Default target</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$(SRCS)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="comment"># Clean up</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<h4 id="14-3-3-CMake">14.3.3 CMake</h4>
<p><strong>CMake</strong>是一个构建系统生成器，可以用CMake来生成Makefiles，就像一个Makefiles的高一层抽象 对于一个<code>CMakeList.txt</code>文件来说，存在以下内容</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(cs106l_classes)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_FILES <span class="string">&quot;*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SRC_FILES&#125;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>set</code>为设定编译器版本为C++20</li>
<li><code>GLOB</code>告诉CMake搜索所有后缀为<code>cpp</code>的文件</li>
<li><code>add_executable</code>该命令将程序的所有源文件添加到可执行文件中 如何使用CMake？</li>
</ul>
<ol>
<li>拥有一个<code>CMakeLists.txt</code></li>
<li>创建一个<code>build</code>文件夹</li>
<li>运行CMake</li>
<li>运行make</li>
<li>执行文件<code>./main</code></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://taffy128.github.io/">lzx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://taffy128.github.io/2025/08/21/CS106L-Winter2025-NOTES/">https://taffy128.github.io/2025/08/21/CS106L-Winter2025-NOTES/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://taffy128.github.io" target="_blank">lzx's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">C++学习笔记</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/21/CS106L-Winter2025-Assignment7-Unique-Pointer/" title="CS106L Winter2025 Assignment7 Unique Pointer"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CS106L Winter2025 Assignment7 Unique Pointer</div></div><div class="info-2"><div class="info-item-1">CS106L Winter2025 Assignment7 Unique Pointer 写在前面 作业地址：CS106L Winter2025 Assignment 以下是Stanford CS106L的第七个作业，需要在学完 RAII, Smart Pointers, Building Projects后完成 具体思路 Part 1: Implementing unique_ptr 本任务需要我们完成自己的unique_ptr，首先回忆一下唯一指针的内容。 唯一指针只能指向一个内容，无法让其他指针复制其内容，无法通过值传递，当变量超出范围时会调用delete，但在此题中无需担心delete。 Implementing unique_ptr functionality 此处需要我们完成几个标出的SMFs  private  这里需要我们在私有处完成内容，对于一个指针来说，它一定会存在的内容是指向一个内容的指针 123private:      T* ptr;      unique_ptr(T*...</div></div></div></a><a class="pagination-related" href="/2025/08/20/CS106L-Winter2025-Assignment6-Explore-Courses/" title="CS106L Winter2025 Assignment6 Explore Courses"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CS106L Winter2025 Assignment6 Explore Courses</div></div><div class="info-2"><div class="info-item-1">CS106L Winter2025 Assignment6 Explore Courses 写在前面 作业地址：CS106L Winter2025 Assignment 以下是Stanford CS106L的第六个作业，需要在学完 std::optional &amp; type safety后完成 具体思路 Part 0: Include &lt;optional&gt; 简单包含头文件即可 1#include &lt;optional&gt; Part 1: Write the find_course...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/13/6-S081-Lab0-Environment-Setup/" title="6.S081_Lab0_Environment Setup"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-13</div><div class="info-item-2">6.S081_Lab0_Environment Setup</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab0_Environment Setup 写在前面 本文旨在为 MIT 6.S081: Operating System Engineering (RISC-V 版本) 的学习者提供一份完整、详尽的开发与调试环境搭建步骤。一个配置完善的环境是高效完成课程实验、深入理解操作系统内核的关键。本教程将引导你完成从安装工具链到配置图形化调试环境的全过程。 第一部分：基础概念 在开始配置前，理解以下几个核心概念，有助于清晰地认识整个开发与调试工作流。 1.1. 宿主机 (Host) 与客户机 (Guest) 整个开发过程涉及两个相互独立的系统环境：  宿主操作系统 (Host OS)：这是你用于开发和编译的系统，通常是一个 Linux 发行版（如 Ubuntu）。所有的开发工具，包括编译器、模拟器和调试器，都安装并运行在宿主机上。 客户操作系统 (Guest OS)：这是你正在学习和开发的操作系统，即 xv6。它运行在由模拟器创建的独立虚拟环境中。  1.2. QEMU 的角色 QEMU 是一个开源的系统模拟器。在本课程中，它的作用是提供一个完整的、软件模拟的...</div></div></div></a><a class="pagination-related" href="/2025/09/13/6-S081-Lab1-Unix-Utilities/" title="6.S081_Lab1_Unix Utilities"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-13</div><div class="info-item-2">6.S081_Lab1_Unix Utilities</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab1_Unix Utilities 写在前面 这是本课程第一次正式Lab，自行完成需要耗费一定的时间 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab1地址 课程首页 0.Makefile 每个任务完成之后需要在Makefile中添加对应的信息才能运行 在UPROGS项下添加以下内容： 12345$U/_sleep\$U/_pingpong\$U/_primes\$U/_find\$U/_xargs\ 1.Sleep 通过sleep系统调用来实现休眠一定时间，注意如果没有传入参数，程序需要打印错误信息 1234567891011#include &quot;kernel/types.h&quot;#include...</div></div></div></a><a class="pagination-related" href="/2025/09/13/6-S081-Lab2-System-calls/" title="6.S081_Lab2_System calls"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-13</div><div class="info-item-2">6.S081_Lab2_System calls</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab2_System calls 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab2地址 课程首页 0.Makefile 每个任务完成之后需要在Makefile中添加对应的信息才能运行 在UPROGS项下添加以下内容： 12$U/_trace\$U/_sysinfotest\ 1.System call tracing 要求：trace [tracing_mask] [command] 要求当调用了给定的tracing mask所对应的system call时，打印输出调用该system call的进程PID、system call的名称、system call的返回值。已经给出了user...</div></div></div></a><a class="pagination-related" href="/2025/09/20/6-S081-Lab3-page-tables/" title="6.S081_Lab3_page tables"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-20</div><div class="info-item-2">6.S081_Lab3_page tables</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab3_page tables 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab3地址 课程首页 1.Speed up system calls 要求：通过在内核与用户空间之间共享一个只读内存页来加速getpid()系统调用，具体做法是在创建进程时分配一个物理页、存入PID，然后将其以只读方式映射到用户虚拟地址USYSCALL，并在进程退出时释放它，从而让用户程序可以直接从内存读取PID，避免陷入内核。 这个 task 的难点在于，你应该把 map page 这段代码放在哪里最合适？Lab 文档里说的是 When each process is created，具体是什么时候呢？是放在 fork 的地方，还是放在 allocproc...</div></div></div></a><a class="pagination-related" href="/2025/09/27/6-S081-Lab4-Traps/" title="6.S081_Lab4_Traps"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-27</div><div class="info-item-2">6.S081_Lab4_Traps</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab4_Traps 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab4地址 课程首页 1.RISC-V assembly 要求：使用make fs.img编译，得到user/call.asm文件，通过阅读call.asm，了解g、f和main函数，并回答以下问题   Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf? a1 里存 12（第一个参数），a2 里存 13（第二个参数），a1、a2 包含函数参数。    Where is the call to function f...</div></div></div></a><a class="pagination-related" href="/2025/11/01/6-S081-Lab6-Multithreading/" title="6.S081_Lab6_Multithreading"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-01</div><div class="info-item-2">6.S081_Lab6_Multithreading</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab6_Multithreading 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab6地址 课程首页 Uthread: switching between threads 实现用户态下的多线程调度。 Hint 已经提示我们了，和内核里的 context switch 一样，只需要报存 callee-saved 寄存器即可。因为这是正常的函数调用，switch 后一段时间后还会返回当前函数的调用栈，剩下的 caller-saved 寄存器，编译器会自动生成恰当的汇编代码帮你保存在栈上。 这部分没有什么难度，把 xv6 中切换的代码抄过来即可。 直接借用内核中定义的 struct context 结构，添加在 struct thread...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">lzx</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Taffy128"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Taffy128" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yyangguangnanhai9@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">CS106L Winter2025 NOTES</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Types-and-Structs"><span class="toc-number">1.1.</span> <span class="toc-text">1. Types and Structs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AFC-%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 什么是C++？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Structs"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 Structs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1 结构体基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E4%BB%80%E4%B9%88%E6%98%AFstd%EF%BC%9F"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2 什么是std？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%94%B9%E8%BF%9B%E6%88%91%E4%BB%AC%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 改进我们的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E4%BD%BF%E7%94%A8using%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1.3.1 使用using关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E4%BD%BF%E7%94%A8auto%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">1.3.2 使用auto关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Initialization-References"><span class="toc-number">1.2.</span> <span class="toc-text">2.Initialization &amp; References</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Initialization"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 Initialization</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-Direct-initialization"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 Direct initialization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Uniform-initialization-C-11"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2 Uniform initialization(C++11)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-Structured-Bingding-C-17"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">2.1.3 Structured Bingding(C++17)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-References"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 References</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-References%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 References简单介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Pass-by-reference"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 Pass by reference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-Passing-by-value"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3 Passing by value</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E6%98%93%E9%94%99%E7%82%B9"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.2.4 按值传递与按引用传递易错点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-L-values-vs-R-values"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 L-values vs R-values</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Const"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 Const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Compiling-C-programs"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 Compiling C++ programs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Streams"><span class="toc-number">1.3.</span> <span class="toc-text">3. Streams</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AFStreams%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 什么是Streams？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-stringstreams"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 stringstreams</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-stringstreams%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">3.2.1 stringstreams简单介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-getline"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">3.2.2 getline()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-cout-and-cin"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 cout and cin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-cout%E7%9A%84%E8%83%8C%E5%90%8E%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1 cout的背后原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Output-File-Streams"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 Output File Streams</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-Output-File-Streams%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">3.4.1 Output File Streams的基本介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-Input-File-Streams"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 Input File Streams</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-Input-File-Streams%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">3.5.1 Input File Streams的基本介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-Input-Streams"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 Input Streams</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-Input-Streams%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">3.6.1 Input Streams的基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-std-cin"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">3.6.2 std::cin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-3-%E5%BD%93std-cin%E5%A4%B1%E8%B4%A5%E6%97%B6"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">3.6.3 当std::cin失败时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Containers"><span class="toc-number">1.4.</span> <span class="toc-text">4. Containers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-What-is-the-STL"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 What is the STL?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-What-are-templates"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">4.1.1 What are templates?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-Containers"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">4.1.2 Containers</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-1-Sequence-Containers"><span class="toc-number">1.4.1.2.1.</span> <span class="toc-text">4.1.2.1 Sequence Containers</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-2-Associative-Containers"><span class="toc-number">1.4.1.2.2.</span> <span class="toc-text">4.1.2.2 Associative Containers</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Iterators"><span class="toc-number">1.5.</span> <span class="toc-text">5. Iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Iterator%E5%9F%BA%E7%A1%80"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 Iterator基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Iterator-Types"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 Iterator Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Pointers-and-Memory"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 Pointers and Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-Memory%E5%9F%BA%E7%A1%80"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">5.3.1 Memory基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E5%8F%98%E9%87%8F%E5%9C%B0%E5%9D%80%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">5.3.2 变量地址表示方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Classes"><span class="toc-number">1.6.</span> <span class="toc-text">6. Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E7%B1%BB%E5%9F%BA%E7%A1%80"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 类基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 结构体与类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E7%B1%BB%E8%AF%AD%E6%B3%95"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 类语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8E%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">6.3.1 头文件与源文件的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E8%AE%BE%E8%AE%A1%E7%B1%BB"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">6.3.2 设计类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Inheritance%EF%BC%88%E7%BB%A7%E6%89%BF%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 Inheritance（继承）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E7%BB%A7%E6%89%BF%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">6.4.1 继承介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E9%92%BB%E7%9F%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">6.4.2 钻石问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Template-Classes"><span class="toc-number">1.7.</span> <span class="toc-text">7. Template Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8E%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 预处理器与宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Templates"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 Templates</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-%E4%B8%80%E4%BA%9B%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%80%AA%E7%99%96"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">7.2.1 一些模板的怪癖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-Const-Correctness"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 Const Correctness</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-Const-interface"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">7.3.1 Const interface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-Const-Cast"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">7.3.2 Const Cast</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Template-Functions"><span class="toc-number">1.8.</span> <span class="toc-text">8. Template Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-Template-Functions"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 Template Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">8.1.1 三元运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E8%B0%83%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">8.1.2 调用模板函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-Concepts"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 Concepts</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Introducing-C-concepts"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">Introducing C++ concepts</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-Variadic-Templates"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 Variadic Templates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-Template-Metaprogramming"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4 Template Metaprogramming</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Functions-and-Lambdas"><span class="toc-number">1.9.</span> <span class="toc-text">9. Functions and Lambdas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-Functions-and-Lambdas"><span class="toc-number">1.9.1.</span> <span class="toc-text">9.1 Functions and Lambdas</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">9.1.1 传递函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-Lambda%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">9.1.2 Lambda函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-3-Functor-%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">9.1.3 Functor(仿函数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-4-%E4%BB%BF%E5%87%BD%E6%95%B0%E4%B8%8ELambda%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.9.1.4.</span> <span class="toc-text">9.1.4 仿函数与Lambda函数之间的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-Algorithms"><span class="toc-number">1.9.2.</span> <span class="toc-text">9.2 Algorithms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-Ranges-and-Views"><span class="toc-number">1.9.3.</span> <span class="toc-text">9.3 Ranges and Views</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-Ranges"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">9.3.1 Ranges</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-Views"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">9.3.2 Views</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Operator-Overloading"><span class="toc-number">1.10.</span> <span class="toc-text">10. Operator Overloading</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-Member-overloading"><span class="toc-number">1.10.1.</span> <span class="toc-text">10.1 Member overloading</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-Non-member-overloading%EF%BC%88%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%89"><span class="toc-number">1.10.2.</span> <span class="toc-text">10.2 Non-member overloading（非成员函数重载）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-friend"><span class="toc-number">1.10.3.</span> <span class="toc-text">10.3 friend</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Special-Member-Functions"><span class="toc-number">1.11.</span> <span class="toc-text">11. Special Member Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-An-overview"><span class="toc-number">1.11.1.</span> <span class="toc-text">11.1 An overview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC"><span class="toc-number">1.11.2.</span> <span class="toc-text">11.2 拷贝与拷贝赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-default%E5%92%8Cdelete"><span class="toc-number">1.11.3.</span> <span class="toc-text">11.3 default和delete</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-1-delete"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">11.3.1 delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-2-default"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">11.3.2 default</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-3-%E4%B8%89%E5%A4%A7%E6%B3%95%E5%88%99"><span class="toc-number">1.11.3.3.</span> <span class="toc-text">11.3.3 三大法则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E7%A7%BB%E5%8A%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC"><span class="toc-number">1.11.4.</span> <span class="toc-text">11.4  移动和移动赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Move-Semantics-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">1.12.</span> <span class="toc-text">12. Move Semantics(移动语义)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC"><span class="toc-number">1.12.1.</span> <span class="toc-text">12.1 左值与右值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">1.12.2.</span> <span class="toc-text">12.2 移动语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-SMFs"><span class="toc-number">1.12.3.</span> <span class="toc-text">12.3 SMFs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-std-optional-type-safety"><span class="toc-number">1.13.</span> <span class="toc-text">13. std::optional &amp; type safety</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-Type-safety"><span class="toc-number">1.13.1.</span> <span class="toc-text">13.1 Type safety</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-std-optional-T"><span class="toc-number">1.13.2.</span> <span class="toc-text">13.2 std::optional&lt; T &gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E6%80%BB%E7%BB%93"><span class="toc-number">1.13.3.</span> <span class="toc-text">13.3 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-RAII-Smart-Pointers-Building-Projects"><span class="toc-number">1.14.</span> <span class="toc-text">14. RAII, Smart Pointers, Building Projects</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-RAII-Resource-Acquisition-Is-Initialization-%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.14.1.</span> <span class="toc-text">14.1 RAII(Resource Acquisition Is Initialization)资源获取即初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-1-Exceptions"><span class="toc-number">1.14.1.1.</span> <span class="toc-text">14.1.1 Exceptions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-2-RAII"><span class="toc-number">1.14.1.2.</span> <span class="toc-text">13.1.2 RAII</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-Smart-Pointers"><span class="toc-number">1.14.2.</span> <span class="toc-text">14.2 Smart Pointers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-Building-C-Projects"><span class="toc-number">1.14.3.</span> <span class="toc-text">14.3 Building C++ Projects</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-1-%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B"><span class="toc-number">1.14.3.1.</span> <span class="toc-text">14.3.1 编译流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-2-Make"><span class="toc-number">1.14.3.2.</span> <span class="toc-text">14.3.2 Make</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-3-CMake"><span class="toc-number">1.14.3.3.</span> <span class="toc-text">14.3.3 CMake</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/26/6-S081-Lab9-File-system/" title="6.S081_Lab9_File system">6.S081_Lab9_File system</a><time datetime="2025-11-26T12:18:38.190Z" title="发表于 2025-11-26 20:18:38">2025-11-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/24/6-S081-Lab8-locks/" title="6.S081_Lab8_locks">6.S081_Lab8_locks</a><time datetime="2025-11-24T14:30:04.484Z" title="发表于 2025-11-24 22:30:04">2025-11-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/23/6-S081-Lab7-networking/" title="6.S081_Lab7_networking">6.S081_Lab7_networking</a><time datetime="2025-11-23T07:42:59.202Z" title="发表于 2025-11-23 15:42:59">2025-11-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/01/6-S081-Lab6-Multithreading/" title="6.S081_Lab6_Multithreading">6.S081_Lab6_Multithreading</a><time datetime="2025-11-01T09:59:23.755Z" title="发表于 2025-11-01 17:59:23">2025-11-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/18/6-S081-Lab5-Copy-on-write-fork/" title="6.S081_Lab5_Copy-on-write fork">6.S081_Lab5_Copy-on-write fork</a><time datetime="2025-10-18T09:40:41.145Z" title="发表于 2025-10-18 17:40:41">2025-10-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By lzx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>