<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CSAPP Notes | lzx's Blog</title><meta name="author" content="lzx"><meta name="copyright" content="lzx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CSAPP Notes Lecture01 数据表示 学习目标  理解计算机系统的复杂与和理论抽象描述的不同 理解内存中数据的保存形式，以及这种方式的好处以及限制 注意避开一些常见的关于计算机的迷思 区别整型和浮点数的表达机制，并理解为什么会有这种差异 简单理解溢出出现的条件  编程误区 因为现在编程难度大幅度降低，许多时候并不需要完全理解底层是如何实现的就可以写出来看的过去的代码，但是由于网上的">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP Notes">
<meta property="og:url" content="https://taffy128.github.io/2025/12/01/CSAPP-Notes/index.html">
<meta property="og:site_name" content="lzx&#39;s Blog">
<meta property="og:description" content="CSAPP Notes Lecture01 数据表示 学习目标  理解计算机系统的复杂与和理论抽象描述的不同 理解内存中数据的保存形式，以及这种方式的好处以及限制 注意避开一些常见的关于计算机的迷思 区别整型和浮点数的表达机制，并理解为什么会有这种差异 简单理解溢出出现的条件  编程误区 因为现在编程难度大幅度降低，许多时候并不需要完全理解底层是如何实现的就可以写出来看的过去的代码，但是由于网上的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://taffy128.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-12-01T09:47:59.973Z">
<meta property="article:modified_time" content="2025-12-01T09:48:31.102Z">
<meta property="article:author" content="lzx">
<meta property="article:tag" content="C++学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://taffy128.github.io/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CSAPP Notes",
  "url": "https://taffy128.github.io/2025/12/01/CSAPP-Notes/",
  "image": "https://taffy128.github.io/img/avatar.jpg",
  "datePublished": "2025-12-01T09:47:59.973Z",
  "dateModified": "2025-12-01T09:48:31.102Z",
  "author": [
    {
      "@type": "Person",
      "name": "lzx",
      "url": "https://taffy128.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://taffy128.github.io/2025/12/01/CSAPP-Notes/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CSAPP Notes',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #FFB6C1;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/CS%20106L/"><span> CS 106L</span></a></li><li><a class="site-page child" href="/categories/%E5%86%85%E5%AD%98%E6%B1%A0/"><span> 内存池</span></a></li><li><a class="site-page child" href="/categories/6-S081/"><span> 6.S081</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">lzx's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">CSAPP Notes</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/CS%20106L/"><span> CS 106L</span></a></li><li><a class="site-page child" href="/categories/%E5%86%85%E5%AD%98%E6%B1%A0/"><span> 内存池</span></a></li><li><a class="site-page child" href="/categories/6-S081/"><span> 6.S081</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CSAPP Notes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-01T09:47:59.973Z" title="发表于 2025-12-01 17:47:59">2025-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-01T09:48:31.102Z" title="更新于 2025-12-01 17:48:31">2025-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CSAPP/">CSAPP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>CSAPP Notes</h1>
<h2 id="Lecture01-数据表示">Lecture01 数据表示</h2>
<h3 id="学习目标">学习目标</h3>
<ol>
<li>理解计算机系统的复杂与和理论抽象描述的不同</li>
<li>理解内存中数据的保存形式，以及这种方式的好处以及限制</li>
<li>注意避开一些常见的关于计算机的迷思</li>
<li>区别整型和浮点数的表达机制，并理解为什么会有这种差异</li>
<li>简单理解溢出出现的条件</li>
</ol>
<h2 id="编程误区">编程误区</h2>
<p>因为现在编程难度大幅度降低，许多时候并不需要完全理解底层是如何实现的就可以写出来看的过去的代码，但是由于网上的一些错误理解以及教材中对概念做的抽象，导致出现了许多“想当然”的问题。想要深入理解计算机系统，就得先把这些误区弄清楚。</p>
<h3 id="计算机不只是执行程序的机器">计算机不只是执行程序的机器</h3>
<p>计算机脱胎于图灵机的构想，简单来说，就是一个能够执行有限逻辑数学过程的计算模型。</p>
<p>图灵机中最重要的两个物理硬件是纸带和读写头，这种抽象非常简单明了，但是很容易给人一种错误印象，即由图灵机发展而来的现代计算机，就是执行程序的机器而已。</p>
<p>计算机学科的发展，与其说是众人拾柴火焰高，不如说是天才引导的历程。真正奠定现代计算机基础的则是冯诺依曼，1945 年发表的 101 页报告，不但提出了二进制的构想，更将计算机分成五大组件（存储器、控制器、运算器、输入、输出），我们现在使用的大部分计算机都符合冯诺依曼架构，“计算机之父“之名绝不为过。</p>
<p>与冯诺依曼架构（也称为普林斯顿架构）齐名另一种架构叫做哈佛架构，它和冯诺依曼架构最大的区别在于能够同时访问数据和指令。虽然在计算机体系架构中黯然退场，但是哈佛结构在移动计算中扮演了非常重要的角色，ARM 架构可能是知名度最高的当红炸子鸡了。</p>
<p>与图灵机相比，这两种架构最重要的突破就是增加的存储器，这使得程序和数据的存储成为可能，也因此衍生出来了数据传输（ I/O）的概念，再加上六十年代末出现的计算机网络，计算机要完成的工作，远不止执行程序这么简单。</p>
<p>冯诺依曼架构也有缺陷，甚至可以这么理解，目前计算机系统的诸多漏洞和不稳定，是在设计之初就注定的。比方说缓存溢出可以执行攻击者预订好的程序，给系统带来巨大的安全风险。虽然我们可以采用各种各样的技术来进行防范，但是道高一尺魔高一丈，比方说采用返回导向编程的堆栈溢出攻击，在出现之后长达十多年里，主流操作系统都毫无防范之力！不过，我们在Lab部分能够亲自体验一把漏洞攻击。</p>
<h3 id="很多东西并不像看起来那样简单">很多东西并不像看起来那样简单</h3>
<p>学习算法的时候肯定离不开思考时间复杂度和空间复杂度，但 <em>O</em>(<em>n</em>^3^) 真的很糟糕，<em>O</em>(1) 真的就很好吗？虽然在单纯的算法分析中是如此，但是在计算机系统中，算法只是一小部分。假设一个 <em>O</em>(1) 的算法会导致死锁，虽然看起来比 <em>O</em>(<em>n</em>^3^) 的算法好得多，然而真正执行起来，可能就是<strong>无尽的等待</strong>了。</p>
<p>程序执行并不是一锤子买卖，从算法到数据表示再到程序流程，从内存到缓存再到运算器。不理解计算机系统本身，不理解程序是如何编译执行，又怎么能够写出好程序呢？</p>
<p>前面提到冯诺依曼架构带来了溢出的问题，二进制和十进制的差异也是的计算机中的数学，和理论上的数学有细微的差异。不要小看这点差异，如果因为忽视了它们而采用了错误的假定，基本是不可能得出准确的结果的，不过话说回来，很多时候计算机中也没有什么<strong>准确的结果</strong>，更多的是<strong>可以表示的结果</strong>。</p>
<p>例如，在纸面上看 (x+1)2≥0(<em>x</em>+1)2≥0 是一定的，但是在计算机中就不一定了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lldb</span><br><span class="line">(lldb) <span class="built_in">print</span> (233333 + 1) * (233333 + 1)</span><br><span class="line">(int) <span class="variable">$0</span> = -1389819292</span><br></pre></td></tr></table></figure>
<p>简单来说，溢出了，就成了负数。但是因为浮点数的表示方法和整数不同，并不会出现因为溢出而变成负数的问题。</p>
<p>那为啥我们不干脆都用浮点数？因为浮点数也有自己的问题，比方说 (x+y)+z=x+(y+z)(<em>x</em>+<em>y</em>)+<em>z</em>=<em>x</em>+(<em>y</em>+<em>z</em>) 在浮点数运算就不一定了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dawang at wdxtub.local in ~ [9:05:02]</span></span><br><span class="line">$ lldb</span><br><span class="line">(lldb) <span class="built_in">print</span> (1e20 + -1e20) + 3.14</span><br><span class="line">(double) <span class="variable">$0</span> = 3.1400000000000001</span><br><span class="line">(lldb) <span class="built_in">print</span> 1e20 + (-1e20 + 3.14)</span><br><span class="line">(double) <span class="variable">$1</span> = 0</span><br></pre></td></tr></table></figure>
<p>交换一下顺序结果就完全不同了，这又是为什么？</p>
<p>因为浮点数的表示方法虽然可以避免溢出（极端情况还是会），但会损失部分精度。</p>
<p>如果一定要在计算机系统中找一个关键词，在我看来一定是<strong>权衡</strong>，在之后的学习过程中，我们会常常看到因为实际与理论的差异不得不做出的妥协，而真正的智慧结晶，则是在妥协的同时找到最接近完美的权衡，可谓<strong>带着镣铐跳舞</strong>。</p>
<h3 id="内存里多的是我们不知道的事">内存里多的是我们不知道的事</h3>
<p>无论是C还是C++都没有提供任何内存保护机制，再加上强大却危险的指针，出现溢出或段错误再正常不过，这类问题的问题在于，很难确定是程序本身的问题，还是编译器或者系统的问题。虽然大部分时候是程序本身的问题，但是我们也很难发现错误根源，毕竟我们没有办法像计算机一样思考。</p>
<p>我们可见的内存并不是物理内存，而是一个非物理的抽象概念。不但需要考虑边界，还得负责空间的分配和管理。假如程序的问题出在动态内存分配上，想要找出来就不那么简单的，毕竟 RAM 中的 R 意思是随机(Random)，要在随机中找确定，难免要花大把的时间。</p>
<h2 id="比特bit">比特bit</h2>
<p>回到这一讲的主要内容-比特(bit)。研究问题有两种方法，一种是自顶向下，另一种是自底向上。对于设计而言，很多时候是自定向下的，从一个整体思想出发，然后不断细化；而在学习化学时，我们都是先学习基本元素，再这些元素的基础上进行更抽象的研究。从这个角度看，<strong>自底向上</strong>学习计算机系统可能是一个好的方向。</p>
<p>在计算机中，我们所看到的一切，归根结底都是比特，每个比特不是0就是1。计算机通过对比特进行不同形式的编码和描述，来执行并完成不同的任务。比特是根据电压的不同来确定是0还是1的，因为电压有一定的容错范围，所以有较高的可信度，故而选用。</p>
<p>在此基础上，计算机就是一个二进制系统，下面这个表格是二进制、十进制和十六进制的对应关系，这三种数字表示形式会在之后反复出现。</p>
<table>
<thead>
<tr>
<th style="text-align:center">十六进制</th>
<th style="text-align:center">十进制</th>
<th style="text-align:center">二进制</th>
<th style="text-align:center">十六进制</th>
<th style="text-align:center">十进制</th>
<th style="text-align:center">二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0000</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1000</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0001</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9</td>
<td style="text-align:center">1001</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0010</td>
<td style="text-align:center">A</td>
<td style="text-align:center">10</td>
<td style="text-align:center">1010</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0011</td>
<td style="text-align:center">B</td>
<td style="text-align:center">11</td>
<td style="text-align:center">1011</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0100</td>
<td style="text-align:center">C</td>
<td style="text-align:center">12</td>
<td style="text-align:center">1100</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0101</td>
<td style="text-align:center">D</td>
<td style="text-align:center">13</td>
<td style="text-align:center">1101</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0110</td>
<td style="text-align:center">E</td>
<td style="text-align:center">14</td>
<td style="text-align:center">1110</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
<td style="text-align:center">0111</td>
<td style="text-align:center">F</td>
<td style="text-align:center">15</td>
<td style="text-align:center">1111</td>
</tr>
</tbody>
</table>
<p>正如加减乘除，比特的基本逻辑运算也有四种，可以看作是布尔代数的子集。对于0和1来说，是这样的：</p>
<ul>
<li>与 And：<code>A=1</code> 且 <code>B=1</code> 时，<code>A&amp;B = 1</code></li>
<li>或 Or：<code>A=1</code> 或 <code>B=1</code> 时，<code>A|B = 1</code></li>
<li>非 Not：<code>A=1</code> 时，<code>~A=0</code>；<code>A=0</code> 时，<code>~A=1</code></li>
<li>异或 Exclusive-Or(Xor)：<code>A=1</code> 或 <code>B=1</code> 时，<code>A^B = 1</code>；<code>A=1</code> 且 <code>B=1</code> 时，<code>A^B = 0</code></li>
</ul>
<p>对应与集合运算则是交集、并集、差集和补集，假设集合 A 是 <code>&#123;0, 3, 5, 6&#125;</code>，集合 B 是 <code>&#123;0, 2, 4, 6&#125;</code>，全集为 <code>&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>，那么：</p>
<ul>
<li><code>&amp;</code> 交集 Intersection <code>&#123;0, 6&#125;</code></li>
<li><code>|</code> 并集 Union <code>&#123;0, 2, 3, 4, 5, 6&#125;</code></li>
<li><code>^</code> 差集 Symmetric difference <code>&#123;2, 3, 4, 5&#125;</code></li>
<li><code>~</code> 补集 Complement <code>&#123;1, 3, 5, 7&#125;</code></li>
</ul>
<p>有了这些知识，我们就可以来具体看看不同类型的数据在计算机中是如何存储和进行运算的了。</p>
<h2 id="整型-Integer">整型 Integer</h2>
<p>C 语言之所以效率高，很大程度上是因为抽象程度较低，很多关键字和计算机系统中的概念是一一对应的。比方说 <code>signed</code> 和 <code>unsigned</code>，就表示有符号数和无符号数。假设字长(word size)为 <code>w</code>，那么二进制向十进制的转换分别是：</p>
<ul>
<li>无符号数：$$B2U(X)=\sum_{i=0}^{w-1} x_i \cdot 2^i$$</li>
<li>有符号数：$$B2T(X)=-x_{w-1} \cdot 2^{w-1} + \sum_{i=0}^{w-2} x_i \cdot 2^i$$</li>
</ul>
<p>有符号数和无符号数的区别主要在于有没有最高位的符号位，以及由此带来的计算方式的不同。符号位中，0 表示非负数，1 表示负数。具体的表示方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">十进制</th>
<th style="text-align:center">十六进制</th>
<th style="text-align:center">二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">15213</td>
<td style="text-align:center">3B 6D</td>
<td style="text-align:center">00111011 01101101</td>
</tr>
<tr>
<td style="text-align:center">-15213</td>
<td style="text-align:center">C4 93</td>
<td style="text-align:center">11000100 10010011</td>
</tr>
</tbody>
</table>
<p>对于二进制数字来说，还有两种常用操作：左移和右移。左移比较简单，在右边补0即可。右移的话分两种，一种是逻辑右移（左边补0），另一种是算术右移（左边补符号位）。为什么会出现这种差异呢？因为对应无符号数和有符号数的运算，有符号数的最高位（最左边）是符号位，在负数的时候需要进行算术右移。</p>
<h3 id="整型表示的特点">整型表示的特点</h3>
<p>接下来我们看看这种表示形式的特点，以及溢出的集中情况，假设字长为 <code>w</code>，定义如下的常量：</p>
<ul>
<li>UMin = 0 即 000…0</li>
<li>UMax = 2*^w^*−1 即 111…1</li>
<li>TMin = −2*^w^*−1 即 100…0</li>
<li>TMax = 2*^w-1^*−1 即 011…1</li>
<li>Minus 1 即 111…1</li>
</ul>
<p>这里的 U 表示无符号数，T 表示补码(Two’s Complement)，对于字长为 16 的情况来说，我们有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">\</th>
<th style="text-align:center">Decimal</th>
<th style="text-align:center">Hex</th>
<th style="text-align:center">Binary</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UMax</td>
<td style="text-align:center">65535</td>
<td style="text-align:center">FF FF</td>
<td style="text-align:center">11111111 11111111</td>
</tr>
<tr>
<td style="text-align:center">TMax</td>
<td style="text-align:center">32767</td>
<td style="text-align:center">7F FF</td>
<td style="text-align:center">01111111 11111111</td>
</tr>
<tr>
<td style="text-align:center">TMin</td>
<td style="text-align:center">-32768</td>
<td style="text-align:center">80 00</td>
<td style="text-align:center">10000000 00000000</td>
</tr>
<tr>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">FF FF</td>
<td style="text-align:center">11111111 11111111</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">00 00</td>
<td style="text-align:center">00000000 00000000</td>
</tr>
</tbody>
</table>
<p>对于不同的 word size，数值也会有很大的变化</p>
<table>
<thead>
<tr>
<th style="text-align:center">w</th>
<th style="text-align:center">8</th>
<th style="text-align:center">16</th>
<th style="text-align:center">32</th>
<th style="text-align:center">64</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UMax</td>
<td style="text-align:center">255</td>
<td style="text-align:center">65,535</td>
<td style="text-align:center">4,294,967,295</td>
<td style="text-align:center">18,446,744,073,709,551,615</td>
</tr>
<tr>
<td style="text-align:center">TMax</td>
<td style="text-align:center">127</td>
<td style="text-align:center">32,767</td>
<td style="text-align:center">2,147,483,647</td>
<td style="text-align:center">9,223,372,036,854,775,807</td>
</tr>
<tr>
<td style="text-align:center">TMin</td>
<td style="text-align:center">-128</td>
<td style="text-align:center">-32,768</td>
<td style="text-align:center">-2,147,483,648</td>
<td style="text-align:center">-9223,372,036,854,775,808</td>
</tr>
</tbody>
</table>
<p>观察可以得知两个很重要的特性</p>
<ul>
<li>|TMin| = TMax + 1 (范围并不是对称的)</li>
<li>UMax = 2*TMax + 1</li>
</ul>
<p>有符号数和无符号数在非负数的编码是一样的，每一个数字的编码是唯一的，这两者可以互换：</p>
<ul>
<li>$$U2B(x) = B2U^{-1}(x)$$</li>
<li>$$T2B(x) = B2T^{-1}(x)$$</li>
</ul>
<h3 id="类型转换">类型转换</h3>
<p>我们在数轴上把有符号数和无符号数画出来的话，就能很清晰的看出相对的关系：</p>
<p>![](C:/Users/阳光男孩/Desktop/代码图片/CSAPP Notes-1.png)</p>
<p>在 C 语言中，如果不加关键字限制，默认的整型是有符号的。如果想要无符号数的话，需要在数字后面加 <code>U</code>，例如下面的代码段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a_signed_number = <span class="number">-15213</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a_unsigned_number = <span class="number">15213U</span>;</span><br></pre></td></tr></table></figure>
<p>在进行有符号和无符号数的互相转换时：</p>
<ul>
<li>具体每一个字节的值不会改变，改变的是<strong>计算机解释当前值的方式</strong></li>
<li>如果一个表达式既包含有符号数也包含无符号数，那么会被隐式转换成无符号数进行比较</li>
</ul>
<p>下面用字长 <code>w = 32</code> 为例，来进行说明，注意这里的每个表达式都是成立的，其中 <code>TMin = -2,147,483,648</code>, <code>TMax = 2,147,483,647</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">比较对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0 == 0U</td>
<td style="text-align:center">无符号数</td>
</tr>
<tr>
<td style="text-align:center">-1 &lt; 0</td>
<td style="text-align:center">有符号数</td>
</tr>
<tr>
<td style="text-align:center">-1 &gt; 0U</td>
<td style="text-align:center">无符号数</td>
</tr>
<tr>
<td style="text-align:center">2147483647 &gt; (-2147483647-1)</td>
<td style="text-align:center">有符号数</td>
</tr>
<tr>
<td style="text-align:center">2147483647U &lt; (-2147483647-1)</td>
<td style="text-align:center">无符号数</td>
</tr>
<tr>
<td style="text-align:center">-1 &gt; -2</td>
<td style="text-align:center">有符号数</td>
</tr>
<tr>
<td style="text-align:center">(unsigned)-1 &gt; -2</td>
<td style="text-align:center">无符号数</td>
</tr>
<tr>
<td style="text-align:center">2147483647 &lt; 2147483648U</td>
<td style="text-align:center">无符号数</td>
</tr>
<tr>
<td style="text-align:center">2147483647 &gt; (int)2147483648U</td>
<td style="text-align:center">有符号数</td>
</tr>
</tbody>
</table>
<h3 id="类型扩展与截取">类型扩展与截取</h3>
<p>具体需要分情况讨论，如：</p>
<ul>
<li>
<p>扩展（例如从<code>short int</code>到<code>int</code>），都可以得到预期的结果</p>
<ul>
<li>无符号数：加 0</li>
<li>有符号数：加符号位</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>截取（例如 <code>unsigned</code> 到 <code>unsigned short</code>），对于小的数字可以得到预期的结果</p>
<ul>
<li>
<p>无符号数：mod 操作</p>
</li>
<li>
<p>有符号数：近似 mod 操作</p>
</li>
</ul>
</li>
</ul>
<p>举个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="type">int</span> x = <span class="number">15213</span>;</span><br><span class="line"><span class="type">int</span> ix = (<span class="type">int</span>) x;</span><br><span class="line"><span class="type">short</span> <span class="type">int</span> y = <span class="number">-15213</span>;</span><br><span class="line"><span class="type">int</span> iy = (<span class="type">int</span>) y;</span><br></pre></td></tr></table></figure>
<p>C 语言会自动做符号拓展，把小的数据类型转换成大的，如下表所示**（前补0或符号位）**</p>
<table>
<thead>
<tr>
<th style="text-align:center">十进制</th>
<th style="text-align:center">十六进制</th>
<th style="text-align:center">二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x=15213</td>
<td style="text-align:center">3B 6D</td>
<td style="text-align:center">00111011 01101101</td>
</tr>
<tr>
<td style="text-align:center">ix=15213</td>
<td style="text-align:center">00 00 3B 6D</td>
<td style="text-align:center">00000000 00000000 00111011 01101101</td>
</tr>
<tr>
<td style="text-align:center">y=-15213</td>
<td style="text-align:center">C4 93</td>
<td style="text-align:center">11000100 10010011</td>
</tr>
<tr>
<td style="text-align:center">iy=-15213</td>
<td style="text-align:center">FF FF C4 93</td>
<td style="text-align:center">11111111 11111111 11000100 10010011</td>
</tr>
</tbody>
</table>
<h3 id="运算与溢出">运算与溢出</h3>
<p>无论是无符号数还是有符号数，一旦用来表示数值的最高位发生了进位，超出了表达形式或者改变了符号位，就会发生溢出。</p>
<p>对于无符号数加法，如果两个 <code>w</code> 位的数字相加，结果是 <code>w+1</code> 位的话，那么就会丢弃掉最高位，实际上是做了一个 mod 操作（公式为 $$s = UAdd_w(u, v) = u + v \mod 2^w$$）</p>
<p>假设 <code>w=3</code>，那么能够表达的数字范围是 <code>000~111(0~7)</code>（括号内为二进制对应的十进制数值，后同），那么如果一个表达式是 <code>110+111(6+7)</code>，原本应该等于 <code>1101(13)</code>，但是由于 <code>w=3</code>，所以最终的结果是 <code>101(5)</code>，也就是发生了溢出，两个无符号数相加，有可能反而变小。</p>
<p>对于<strong>有符号的加法</strong>(Two’s Complement Addition)，操作过程和无符号加法一样，只是解释的时候会有不同，因此会得到正溢出(positive overflow)和负溢出(negative overflow)两种。正溢出就是数值太大把原来为 0 的符号位修改成了 1，反而成了负数；负溢出是数值太小，把原来为 1 的符号位修改成了 0，反而成了正数。</p>
<p>还是用刚才 <code>w=3</code> 作为例子，能够表达的数字范围是 <code>100~011(-4~3)</code>，如果一个表达式是 <code>011+010(3+2)</code>，理论上应该等于 5，但是相加之后变成了 <code>101(-3)</code>，也就是发生了正溢出。如果一个表达式是 <code>100+101(-4+(-3))</code>，理论上应该等于 -7，但是相加后进位截取变成了 <code>001(1)</code>，也就是发生了负溢出。</p>
<p>对于乘法来说，值的范围会大很多，这里分情况讨论一下，假设两个乘数是 x,y 并且都是 w 位的：</p>
<ul>
<li>无符号数：至多 2w 位
<ul>
<li>范围 $$0 \leq x \times y \leq (2^w - 1)^2 = 2^{2w} - 2^{w+1} + 1$$</li>
</ul>
</li>
<li>有符号数，最小的负数：至多 2w - 1 位
<ul>
<li>范围 $$x \times y \geq (-2^{w-1}) \times (2^{w-1} - 1) = -2^{2w-2} + 2^{w-1}$$</li>
</ul>
</li>
<li>有符号数，最大的正数：至多 2w 位，只有一种情况
<ul>
<li>范围 $$x \times y \leq (-2^{w-1})^2 = 2^{2w-2}$$</li>
</ul>
</li>
</ul>
<p>如果需要保证精度，就需要用软件来实现了。另外，计算的无符号乘法的时候，会忽略最高的 w 位，相当于 $$UMult_w(u, v) = u \cdot v\mod 2^w$$</p>
<h2 id="浮点数-Float">浮点数 Float</h2>
<p>浮点数可以用一个统一的公式来表达：</p>
<p>$$\sum_{k=-j}^{i}b_{k}\times2^{k}$$</p>
<p>例如</p>
<p>$$5\frac{3}{4} = 101.11_{2}$$，$$2\frac{7}{8} = 10.111_{2}$$，$$1\frac{7}{16} = 1.0111_{2}$$</p>
<p>可以看到除以二就相当于右移，并且可以横跨小数点。注意 $$0.111…_{2}$$非常接近于 1，因为</p>
<p>$1/2+1/4+1/8+…+1/2^i+…→1.0$</p>
<p>通常用 $1.0−ϵ$ 来表示这个值。</p>
<p>这种表达方式其实是比较明显的限制的，比如说，只有形为 $$\frac{x}{2^k}$$ 的小数部分可以被精确表示，其他的数字会变成循环的小数，例如：$$\frac{1}{3}=0.0101010101[01]…_{2}$$。</p>
<p>另一个问题在于，如果给定了 w 个比特，能够表达的数字其实是有限的，具体的原因会在后面详细解释。</p>
<h3 id="IEEE-浮点数标准">IEEE 浮点数标准</h3>
<p>IEEE的浮点数标准更多是从数值角度来建立的，对于舍入，上溢出和下溢出都有比较统一的处理方法。但同时也给硬件优化带来比较大的挑战。因为和平时使用的数制有一定差异，从理解的角度来看不够直观，但是好在主流的CPU都支持浮点数，所以我们不必过多涉及这方面的细节。</p>
<p>在IEEE标准中，我们用如下公式来表达浮点数</p>
<p>$$(-1)^{s}M2^{E}$$</p>
<p>其中 s 是符号位，决定正负；M 通常是一个值在 <strong>[1.0, 2.0)</strong> 的小数；E 是次方数。具体编码时结构如下，这里用单精度、双精度和扩展精度为例：</p>
<p>![](C:/Users/阳光男孩/Desktop/代码图片/CSAPP Notes-2.png)</p>
<p>其中 <code>s</code> 对应着符号位，<code>exp</code> 对应着 E（注意，不一定等于 E，因为位数限制表达能力有限），<code>frac</code> 对应着 M（注意，不一定等于 M，因为位数限制表达能力有限）。不同的位数就代表了不同的表示能力，也就是单精度，双精度，扩展精度的来源。</p>
<p><strong>规范化值(Normalized Values)</strong></p>
<p>在 $$exp≠000…0$$和 $$exp≠111…1$$ 时，表示的其实都是规范化的值，为什么说是规范化呢？这里只需要大概知道因为实数轴上原来连续的值会被规范到有限的定值上并且这些定值之间的间距也是不一样的，具体可以通过后面给出的例子来理解（所以现在不明白也不用担心）</p>
<p>再来回顾一下我们计算浮点数的公式：</p>
<p>$$v=(-1)^{s}M2^{E}$$</p>
<p>这里的 E 是一个偏移的值 $$E=Exp−Bias$$，其中</p>
<ul>
<li>Exp: 是 exp 编码区域的无符号数值</li>
<li>Bias：值为$$2^{k-1}-1$$的偏移量，其中 k 是 exp 编码的位数，也就是说
<ul>
<li>单精度：127（Exp: 1…254, E: -126…127）</li>
<li>双精度：1023（Exp: 1…2046, E: -1022…1023）</li>
</ul>
</li>
</ul>
<p>之所以需要采用一个偏移量，是为了保证 exp 编码只需要以无符号数来处理。</p>
<p>而对于 M，一定是以 1 开头的：也就是 $$<a target="_blank" rel="noopener" href="http://M=1.xxx">M=1.xxx</a>…x_{2}$$。其中 xxx 的部分就是 frac 的编码部分，当 frac=000.00 的时候值最小（$$M=1.0$$），当 frac=111…1 的时候值最大（$$M=2.0−ϵ$$），也就是说开头的 1 是<strong>免费附送的</strong>，并不需要实际的编码位。也就是说<strong>虽然frac分配了23位，但是实际上我们可以表示一个24位的数字</strong></p>
<p>举个例子，<code>float F = 15213.0;</code>，那么</p>
<p>$$15213_{10}=11101101101101_{2}=1.1101101101101_{2}×2^{13}$$</p>
<p>于是 frac 部分的值就是小数点后面的数值，而 Exp = E + Bias = 13 + 127 = 140 = 100011002100011002，于是编码出来的浮点数是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 10001100 11011011011010000000000</span><br><span class="line">s   exp             frac</span><br></pre></td></tr></table></figure>
<p><strong>非规范化值(Denormalized Values)</strong></p>
<p>当 $$exp=000…0$$的时候，值是非规范化的，意思是，虽然实数轴上原来连续的值会被规范到有限的定值上，但是并些定值之间的间距也是一样的，具体可以通过后面给出的例子来理解</p>
<p>$$v=(-1)^{s}M2^{E}$$</p>
<p>和前面不同的是</p>
<p>$$E = 1-Bias$$</p>
<p>而且 $$<a target="_blank" rel="noopener" href="http://M=0.xxx">M=0.xxx</a>…x_{2}$$，不是以 1 开头了。</p>
<p>当 $$exp=000…0$$ 且 $$frac = 000…0$$ 时，表示 0，而且因为符号位的缘故，实际上是有 +0 和 -0 两种的。而在 $$exp=000…0$$ 且 $$frac≠000…0$$ 时，数值是接近 0 的，并且间距是一致的</p>
<p><strong>特殊值</strong></p>
<p>还有一种特殊情况，就是 $$exp=111…1$$ 时，表示一些特殊值。</p>
<p>当 $$exp=111…1 $$ 且 $$frac = 000…0$$ 时，表示 $$∞$$，而且因为符号位的缘故，实际上是有 $$+∞$$ 和 $$−∞$$ 两种的。那些会溢出的操作就会用这个来表示，比如 $$1.0/0.0=−1.0/0.0=+∞$$  ,  $$1.0/−0.0=−∞$$</p>
<p>而在 $$exp=111…1$$ 且 $$frac≠000…0$$ 时，我们认为这不是一个数值（Not-a-Number，NaN），用来表示那些没办法确定的值，比如 $$sqrt(−1),∞−∞,∞×0$$</p>
<h3 id="实例学习">实例学习</h3>
<p>我们来看看上面各种情况对应到数轴中是怎么样的：</p>
<p>![](C:/Users/阳光男孩/Desktop/代码图片/CSAPP Notes-3.png)</p>
<p>接下来举一个实际的例子，我们采用 1 位符号位，4 位 exp 位，3 位 frac 位，因此对应的 bias 为 7。回顾一下几个重要公式：</p>
<p>$$v=(-1)^{s}M2^{E}$$</p>
<p>对于规范化数：$$E=Exp−Bias$$；对于非规范数：$$E = 1-Bias$$，正数部分的数值为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    s exp  frac   E   值</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">    0 0000 000   -6   0   <span class="comment"># 这部分是非规范化数值，下一部分是规范化值</span></span><br><span class="line">    0 0000 001   -6   1/8 * 1/64 = 1/512 <span class="comment"># 能表示的最接近零的值</span></span><br><span class="line">    0 0000 010   -6   2/8 * 1/64 = 2/512 </span><br><span class="line">    ...</span><br><span class="line">    0 0000 110   -6   6/8 * 1/64 = 6/512</span><br><span class="line">    0 0000 111   -6   7/8 * 1/64 = 7/512 <span class="comment"># 能表示的最大非规范化值</span></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">    0 0001 000   -6   8/8 * 1/64 = 8/512 <span class="comment"># 能表示的最小规范化值</span></span><br><span class="line">    0 0001 001   -6   9/8 * 1/64 = 9/512</span><br><span class="line">    ...</span><br><span class="line">    0 0110 110   -1   14/8 * 1/2 = 14/16</span><br><span class="line">    0 0110 111   -1   15/8 * 1/2 = 15/16 <span class="comment"># 最接近且小于 1 的值</span></span><br><span class="line">    0 0111 000    0   8/8 * 1 = 1</span><br><span class="line">    0 0111 001    0   9/8 * 1 = 9/8      <span class="comment"># 最接近且大于 1 的值</span></span><br><span class="line">    0 0111 010    0   10/8 * 1 = 10/8</span><br><span class="line">    ...</span><br><span class="line">    0 1110 110    7   14/8 * 128 = 224</span><br><span class="line">    0 1110 111    7   15/8 * 128 = 240   <span class="comment"># 能表示的最大规范化值</span></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">    0 1111 000   n/a  无穷               <span class="comment"># 特殊值</span></span><br></pre></td></tr></table></figure>
<p>观察上表，我们可以发现如下一些比较有意思的规律：</p>
<ul>
<li>在 <code>exp=0000</code> 时，也就是非规范化的情况，间距是一致的，都是 1/8</li>
<li>因为位数的限制，从零到一之间的数字只能以 1/8 为最小单位来表示，且相邻数字间间距一样</li>
<li>在规范化的部分，可以发现由于 exp 部分的不同，所以相邻数字间的间隔也是不同的，比方说最接近 1 的数字是 15/16 和 9/8，分别相差 1/16 和 1/8，这也是由于 IEEE 浮点数表示法的公式决定的</li>
</ul>
<h3 id="舍入">舍入</h3>
<p>对于浮点数的加法和乘法来说，我们可以先计算出准确值，然后转换到合适的精度。在这个过程中，既可能会溢出，也可能需要舍入来满足 frac 的精度。</p>
<p>在二进制中，我们舍入到最近的偶数，即如果出现在中间的情况，舍入之后最右边的值要是偶数，对于十进制数，例子如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  原数值       舍入结果    原因</span><br><span class="line">2.8949999      2.89    不到一半，正常四舍五入</span><br><span class="line">2.8950001      2.90    超过一般，正常四舍五入</span><br><span class="line">2.8950000      2.90    刚好在一半时，保证最后一位是偶数，所以向上舍入</span><br><span class="line">2.8850000      2.88    刚好在一半时，保证最后一位是偶数，所以向下舍入</span><br></pre></td></tr></table></figure>
<p>对于二进制数也是类似的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  十进制    二进制     舍入结果  十进制    原因</span><br><span class="line">2 又 3/32  10.00011   10.00     2      不到一半，正常四舍五入</span><br><span class="line">2 又 3/16  10.00110   10.01  2 又 1/4   超过一般，正常四舍五入</span><br><span class="line">2 又 7/8   10.11100   11.00     3      刚好在一半时，保证最后一位是偶数，所以向上舍入</span><br><span class="line">2 又 5/8   10.10100   10.10  2 又 1/2   刚好在一半时，保证最后一位是偶数，所以向下舍入</span><br></pre></td></tr></table></figure>
<h3 id="浮点数加法">浮点数加法</h3>
<p>$$(−1)^{s_{1}}M_{1}2^{E_{1}}+(−1)^{s_{2}}M_{2}2^{E_{2}}$$</p>
<p>这里假设 $$E1&gt;E2$$，结果是 $$(−1)^{s}  M  2^{E}$$ ，其中 $$s=s_{1}∧s_{2},M=M_{1}+M_{2},E=E_{1}$$</p>
<ul>
<li>如果 $$M ≥ 2$$，那么把 M 右移，并增加 E 的值</li>
<li>如果 $$M &lt; 1$$，把 M 左移 k 位，E 减少 k</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相加可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失，如 <code>(3.14+1e10)-1e10=0</code>，但 <code>3.14+(1e10-1e10)=3.14</code>）</li>
<li>加上 0 等于原来的数</li>
<li>除了 infinity 和 NaN，每个元素都有对应的倒数</li>
<li>除了 infinity 和 NaN，满足单调性，即 $$a≥b→a+c≥b+c$$</li>
</ul>
<h3 id="浮点数乘法">浮点数乘法</h3>
<p>$$(−1)^{s_{1}}M_{1}2^{E_{1}}\times(−1)^{s_{2}}M_{2}2^{E_{2}}$$</p>
<p>结果是 $$(−1)^{s}  M  2^{E}$$，其中 $$s=s_{1}∧s_{2},M=M_{1}\times M_{2},E=E_{1}+E_{2}$$</p>
<ul>
<li>如果 $$M ≥ 2$$，那么把 M 右移，并增加 E 的值。</li>
<li>如果 E 超出了可以表示的范围，溢出</li>
<li>把 M 舍入到 frac 的精度</li>
</ul>
<p>基本性质</p>
<ul>
<li>相乘可能产生 infinity 或者 NaN</li>
<li>满足交换率</li>
<li>不满足结合律（因为舍入会造成精度损失）</li>
<li>乘以 1 等于原来的数</li>
<li>不满足分配律 <code>1e20*(1e20-1e20)=0.0</code> 但 <code>1e20*1e20-1e20*1e20=NaN</code></li>
<li>除了 infinity 和 NaN，满足单调性，即 a≥b→a×c≥a×b<em>a</em>≥<em>b</em>→<em>a</em>×<em>c</em>≥<em>a</em>×<em>b</em></li>
</ul>
<h2 id="数据在内存中的形式">数据在内存中的形式</h2>
<p>后续章节会有关于内存的详细介绍，这里我们只要知道不同数据类型所占据的字节数，以及大端-小端规则即可。</p>
<p>操作系统会给每个进程提供私有的虚拟内存地址空间，一个进程可以访问自己的数据，但是不能访问别人的数据。在虚拟内存中地址是连续的，对应物理内存则不一定，根据字长的不同，有不同的间隔，如下图所示</p>
<p>![](C:/Users/阳光男孩/Desktop/代码图片/CSAPP Notes-4.png)</p>
<p>然后我们来看看常见数据类型所需要的字节数：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">32 位</th>
<th style="text-align:center">64 位</th>
<th style="text-align:center">x86-64</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">4</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">long double</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">10/16</td>
</tr>
<tr>
<td style="text-align:center">指针</td>
<td style="text-align:center">4</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
<p>数据具体的排列也有两种方式：大端(Big Endian)与小段(Little Endian)，区别在于高位地址的位置。Internet数据采用大端规则，而我们常见的 x86 或 ARM 处理器都采用小端规则。</p>
<p>比如，假如变量 <code>x</code> 是 4 字节，值为 <code>0x01234567</code> 。用 <code>&amp;x</code> 索引的地址是 <code>0x100</code>，那么大端和小端的表示形式是</p>
<p>![](C:/Users/阳光男孩/Desktop/代码图片/CSAPP Notes-5.png)</p>
<p>如何检查数据的表示呢，可以用下面的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> *pointer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(pointer start, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%p\t0x%.2x\n&quot;</span>, start+i, start[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>%p</code> 用来输出指针，<code>%x</code> 用来输出 16 进制数据。执行可用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">15213</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int a = 15213;\n&quot;</span>);</span><br><span class="line">show_bytes((pointer) &amp;a, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<p>在我的电脑上，测试如下：</p>
<p>![](C:/Users/阳光男孩/Desktop/代码图片/CSAPP Notes-6.png)</p>
<h2 id="总结">总结</h2>
<p>这一讲，我们从编程的常见误区开始，简要介绍了计算机架构。并从最基本的元素——比特开始，逐步说明了整型和浮点数这两个非常重要的基础数据类型。这之中涉及了类型转换、扩展与截取、运算与溢出。浮点数因为 IEEE 标准与常识的差异，通过具体的例子进行了讲解，最后引出了舍入的概念。</p>
<p>需要注意的是，这部分内容知识点比较零碎，需要通过具体例子去理解。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://taffy128.github.io/">lzx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://taffy128.github.io/2025/12/01/CSAPP-Notes/">https://taffy128.github.io/2025/12/01/CSAPP-Notes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://taffy128.github.io" target="_blank">lzx's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">C++学习笔记</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/11/28/6-S081-Lecture-Notes/" title="6.S081_Lecture Notes"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">6.S081_Lecture Notes</div></div><div class="info-2"><div class="info-item-1">6.S081_Lecture Notes 课程网址：https://pdos.csail.mit.edu/6.S081/2020/index.html Lecture 1 Introduction 操作系统应该提供的功能：1. 多进程支持 2. 进程间隔离 3. 受控制的进程间通信  xv6：一种在本课程中使用的类UNIX的教学操作系统，运行在RISC-V指令集处理器上，本课程中将使用QEMU模拟器代替 kernel(内核)：为运行的程序提供服务的一种特殊程序。每个运行着的程序叫做进程，每个进程的内存中存储指令、数据和堆栈。一个计算机可以拥有多个进程，但是只能有一个内核  每当进程需要调用内核时，它会触发一个system call（系统调用），system call进入内核执行相应的服务然后返回。   shell：一个普通的程序，其功能是让用户输入命令并执行它们，shell不是内核的一部分  1.1 Processes and...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/13/6-S081-Lab0-Environment-Setup/" title="6.S081_Lab0_Environment Setup"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-13</div><div class="info-item-2">6.S081_Lab0_Environment Setup</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab0_Environment Setup 写在前面 本文旨在为 MIT 6.S081: Operating System Engineering (RISC-V 版本) 的学习者提供一份完整、详尽的开发与调试环境搭建步骤。一个配置完善的环境是高效完成课程实验、深入理解操作系统内核的关键。本教程将引导你完成从安装工具链到配置图形化调试环境的全过程。 第一部分：基础概念 在开始配置前，理解以下几个核心概念，有助于清晰地认识整个开发与调试工作流。 1.1. 宿主机 (Host) 与客户机 (Guest) 整个开发过程涉及两个相互独立的系统环境：  宿主操作系统 (Host OS)：这是你用于开发和编译的系统，通常是一个 Linux 发行版（如 Ubuntu）。所有的开发工具，包括编译器、模拟器和调试器，都安装并运行在宿主机上。 客户操作系统 (Guest OS)：这是你正在学习和开发的操作系统，即 xv6。它运行在由模拟器创建的独立虚拟环境中。  1.2. QEMU 的角色 QEMU 是一个开源的系统模拟器。在本课程中，它的作用是提供一个完整的、软件模拟的...</div></div></div></a><a class="pagination-related" href="/2025/11/28/6-S081-Lab10-Mmap/" title="6.S081_Lab10_Mmap"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-28</div><div class="info-item-2">6.S081_Lab10_Mmap</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab10_Mmap 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab10地址 课程首页 Lab10 核心数据结构 实现 mmap 的核心数据结构是 Linux 中的 vm_area_struct，下面是 CSAPP 的经典好图：  start 和 end 是一个左闭右开的区间，即 [start, end) 在 Linux 内核中，VMA 是通过红黑树以起始地址为关键字来实现快速增删改查的，在这个 Lab 实现中，我就用单链表来把 VMA 串一起就行了，因此 struct vma 的定义如下： 123456789struct vma &#123;  uint64 start;  uint64 end;  int prot;  int flags;...</div></div></div></a><a class="pagination-related" href="/2025/09/13/6-S081-Lab1-Unix-Utilities/" title="6.S081_Lab1_Unix Utilities"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-13</div><div class="info-item-2">6.S081_Lab1_Unix Utilities</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab1_Unix Utilities 写在前面 这是本课程第一次正式Lab，自行完成需要耗费一定的时间 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab1地址 课程首页 0.Makefile 每个任务完成之后需要在Makefile中添加对应的信息才能运行 在UPROGS项下添加以下内容： 12345$U/_sleep\$U/_pingpong\$U/_primes\$U/_find\$U/_xargs\ 1.Sleep 通过sleep系统调用来实现休眠一定时间，注意如果没有传入参数，程序需要打印错误信息 1234567891011#include &quot;kernel/types.h&quot;#include...</div></div></div></a><a class="pagination-related" href="/2025/09/20/6-S081-Lab3-page-tables/" title="6.S081_Lab3_page tables"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-20</div><div class="info-item-2">6.S081_Lab3_page tables</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab3_page tables 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab3地址 课程首页 1.Speed up system calls 要求：通过在内核与用户空间之间共享一个只读内存页来加速getpid()系统调用，具体做法是在创建进程时分配一个物理页、存入PID，然后将其以只读方式映射到用户虚拟地址USYSCALL，并在进程退出时释放它，从而让用户程序可以直接从内存读取PID，避免陷入内核。 这个 task 的难点在于，你应该把 map page 这段代码放在哪里最合适？Lab 文档里说的是 When each process is created，具体是什么时候呢？是放在 fork 的地方，还是放在 allocproc...</div></div></div></a><a class="pagination-related" href="/2025/09/13/6-S081-Lab2-System-calls/" title="6.S081_Lab2_System calls"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-13</div><div class="info-item-2">6.S081_Lab2_System calls</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab2_System calls 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab2地址 课程首页 0.Makefile 每个任务完成之后需要在Makefile中添加对应的信息才能运行 在UPROGS项下添加以下内容： 12$U/_trace\$U/_sysinfotest\ 1.System call tracing 要求：trace [tracing_mask] [command] 要求当调用了给定的tracing mask所对应的system call时，打印输出调用该system call的进程PID、system call的名称、system call的返回值。已经给出了user...</div></div></div></a><a class="pagination-related" href="/2025/09/27/6-S081-Lab4-Traps/" title="6.S081_Lab4_Traps"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-27</div><div class="info-item-2">6.S081_Lab4_Traps</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab4_Traps 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab4地址 课程首页 1.RISC-V assembly 要求：使用make fs.img编译，得到user/call.asm文件，通过阅读call.asm，了解g、f和main函数，并回答以下问题   Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf? a1 里存 12（第一个参数），a2 里存 13（第二个参数），a1、a2 包含函数参数。    Where is the call to function f...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">lzx</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Taffy128"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Taffy128" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yyangguangnanhai9@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">CSAPP Notes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture01-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.1.</span> <span class="toc-text">Lecture01 数据表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.1.</span> <span class="toc-text">学习目标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E8%AF%AF%E5%8C%BA"><span class="toc-number">1.2.</span> <span class="toc-text">编程误区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8D%E5%8F%AA%E6%98%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">计算机不只是执行程序的机器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%88%E5%A4%9A%E4%B8%9C%E8%A5%BF%E5%B9%B6%E4%B8%8D%E5%83%8F%E7%9C%8B%E8%B5%B7%E6%9D%A5%E9%82%A3%E6%A0%B7%E7%AE%80%E5%8D%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">很多东西并不像看起来那样简单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%87%8C%E5%A4%9A%E7%9A%84%E6%98%AF%E6%88%91%E4%BB%AC%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">内存里多的是我们不知道的事</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E7%89%B9bit"><span class="toc-number">1.3.</span> <span class="toc-text">比特bit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B-Integer"><span class="toc-number">1.4.</span> <span class="toc-text">整型 Integer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E8%A1%A8%E7%A4%BA%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.1.</span> <span class="toc-text">整型表示的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.2.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%89%A9%E5%B1%95%E4%B8%8E%E6%88%AA%E5%8F%96"><span class="toc-number">1.4.3.</span> <span class="toc-text">类型扩展与截取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E4%B8%8E%E6%BA%A2%E5%87%BA"><span class="toc-number">1.4.4.</span> <span class="toc-text">运算与溢出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0-Float"><span class="toc-number">1.5.</span> <span class="toc-text">浮点数 Float</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IEEE-%E6%B5%AE%E7%82%B9%E6%95%B0%E6%A0%87%E5%87%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">IEEE 浮点数标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.5.2.</span> <span class="toc-text">实例学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%88%8D%E5%85%A5"><span class="toc-number">1.5.3.</span> <span class="toc-text">舍入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E6%B3%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">浮点数加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B9%98%E6%B3%95"><span class="toc-number">1.5.5.</span> <span class="toc-text">浮点数乘法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">数据在内存中的形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/01/CSAPP-Notes/" title="CSAPP Notes">CSAPP Notes</a><time datetime="2025-12-01T09:47:59.973Z" title="发表于 2025-12-01 17:47:59">2025-12-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/28/6-S081-Lecture-Notes/" title="6.S081_Lecture Notes">6.S081_Lecture Notes</a><time datetime="2025-11-28T10:45:48.815Z" title="发表于 2025-11-28 18:45:48">2025-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/28/6-S081-Lab10-Mmap/" title="6.S081_Lab10_Mmap">6.S081_Lab10_Mmap</a><time datetime="2025-11-28T10:43:14.371Z" title="发表于 2025-11-28 18:43:14">2025-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/26/6-S081-Lab9-File-system/" title="6.S081_Lab9_File system">6.S081_Lab9_File system</a><time datetime="2025-11-26T12:18:38.190Z" title="发表于 2025-11-26 20:18:38">2025-11-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/24/6-S081-Lab8-locks/" title="6.S081_Lab8_locks">6.S081_Lab8_locks</a><time datetime="2025-11-24T14:30:04.484Z" title="发表于 2025-11-24 22:30:04">2025-11-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By lzx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>