<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>6.S081_Lecture Notes | lzx's Blog</title><meta name="author" content="lzx"><meta name="copyright" content="lzx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="6.S081_Lecture Notes 课程网址：https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.S081&#x2F;2020&#x2F;index.html Lecture 1 Introduction 操作系统应该提供的功能：1. 多进程支持 2. 进程间隔离 3. 受控制的进程间通信  xv6：一种在本课程中使用的类UNIX的教学操作系统，运行在RISC-V指令集处理器上，本课程中将使用QEMU模拟">
<meta property="og:type" content="article">
<meta property="og:title" content="6.S081_Lecture Notes">
<meta property="og:url" content="https://taffy128.github.io/2025/11/28/6-S081-Lecture-Notes/index.html">
<meta property="og:site_name" content="lzx&#39;s Blog">
<meta property="og:description" content="6.S081_Lecture Notes 课程网址：https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.S081&#x2F;2020&#x2F;index.html Lecture 1 Introduction 操作系统应该提供的功能：1. 多进程支持 2. 进程间隔离 3. 受控制的进程间通信  xv6：一种在本课程中使用的类UNIX的教学操作系统，运行在RISC-V指令集处理器上，本课程中将使用QEMU模拟">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://taffy128.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-11-28T10:45:48.815Z">
<meta property="article:modified_time" content="2025-11-28T10:49:04.597Z">
<meta property="article:author" content="lzx">
<meta property="article:tag" content="C++学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://taffy128.github.io/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "6.S081_Lecture Notes",
  "url": "https://taffy128.github.io/2025/11/28/6-S081-Lecture-Notes/",
  "image": "https://taffy128.github.io/img/avatar.jpg",
  "datePublished": "2025-11-28T10:45:48.815Z",
  "dateModified": "2025-11-28T10:49:04.597Z",
  "author": [
    {
      "@type": "Person",
      "name": "lzx",
      "url": "https://taffy128.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://taffy128.github.io/2025/11/28/6-S081-Lecture-Notes/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '6.S081_Lecture Notes',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #FFB6C1;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/CS%20106L/"><span> CS 106L</span></a></li><li><a class="site-page child" href="/categories/%E5%86%85%E5%AD%98%E6%B1%A0/"><span> 内存池</span></a></li><li><a class="site-page child" href="/categories/6-S081/"><span> 6.S081</span></a></li><li><a class="site-page child" href="/categories/CSAPP/"><span> CSAPP</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">lzx's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">6.S081_Lecture Notes</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/CS%20106L/"><span> CS 106L</span></a></li><li><a class="site-page child" href="/categories/%E5%86%85%E5%AD%98%E6%B1%A0/"><span> 内存池</span></a></li><li><a class="site-page child" href="/categories/6-S081/"><span> 6.S081</span></a></li><li><a class="site-page child" href="/categories/CSAPP/"><span> CSAPP</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">6.S081_Lecture Notes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-28T10:45:48.815Z" title="发表于 2025-11-28 18:45:48">2025-11-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-28T10:49:04.597Z" title="更新于 2025-11-28 18:49:04">2025-11-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/6-S081/">6.S081</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>6.S081_Lecture Notes</h1>
<p>课程网址：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/index.html">https://pdos.csail.mit.edu/6.S081/2020/index.html</a></p>
<h2 id="Lecture-1-Introduction">Lecture 1 Introduction</h2>
<p>操作系统应该提供的功能：1. 多进程支持 2. 进程间隔离 3. 受控制的进程间通信</p>
<ul>
<li><em>xv6</em>：一种在本课程中使用的类UNIX的教学操作系统，运行在RISC-V指令集处理器上，本课程中将使用<em>QEMU</em>模拟器代替</li>
<li><em>kernel</em>(内核)：为运行的程序提供服务的一种特殊程序。每个运行着的程序叫做进程，每个进程的内存中存储指令、数据和堆栈。一个计算机可以拥有多个进程，但是只能有一个内核</li>
</ul>
<p>每当进程需要调用内核时，它会触发一个<em>system call</em>（系统调用），system call进入内核执行相应的服务然后返回。</p>
<p><img src="/images/6.S081notes-1.png" alt></p>
<ul>
<li><em>shell</em>：一个普通的程序，其功能是让用户输入命令并执行它们，shell不是内核的一部分</li>
</ul>
<h3 id="1-1-Processes-and-memory">1.1 Processes and memory</h3>
<p>每个进程拥有自己的用户空间内存以及内核空间状态，当进程不再执行时xv6将存储和这些进程相关的CPU寄存器直到下一次运行这些进程。kernel将每一个进程用一个PID(process identifier)指代。</p>
<p><strong>常用syscall</strong></p>
<ul>
<li><code>fork</code>：形式：<code>int fork()</code>。其作用是让一个进程生成另外一个和这个进程的内存内容相同的子进程。在父进程中，<code>fork</code>的返回值是这个子进程的PID，在子进程中，返回值是0</li>
<li><code>exit</code>：形式：<code>int exit(int status)</code>。让调用它的进程停止执行并且将内存等占用的资源全部释放。需要一个整数形式的状态参数，0代表以正常状态退出，1代表以非正常状态退出</li>
<li><code>wait</code>：形式：<code>int wait(int *status)</code>。等待子进程退出，返回子进程PID，子进程的退出状态存储到<code>int *status</code>这个地址中。如果调用者没有子进程，<code>wait</code>将返回-1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">    pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前两行输出可能是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent: child=1234</span><br><span class="line">child: exiting</span><br></pre></td></tr></table></figure>
<p>也可能是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child: exiting</span><br><span class="line">parent: child=1234</span><br></pre></td></tr></table></figure>
<p>这是因为在fork了之后，父进程和子进程将同时开始判断PID的值，在父进程中，PID为1234，而在子进程中，PID为0。看哪个进程先判断好PID的值，以上输出顺序才会被决定。</p>
<p>最后一行输出为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent: child 1234 is done</span><br></pre></td></tr></table></figure>
<p>子进程在判断完<code>pid == 0</code>之后将<code>exit</code>，父进程发现子进程<code>exit</code>之后，<code>wait</code>执行完毕，打印输出</p>
<p>尽管<code>fork</code>了之后子进程和父进程有相同的内存内容，但是内存地址和寄存器是不一样的，也就是说在一个进程中改变变量并不会影响另一个进程。</p>
<ul>
<li>
<p><code>exec</code>：形式：<code>int exec(char *file, char *argv[])</code>。加载一个文件，获取执行它的参数，执行。如果执行错误返回-1，执行成功则不会返回，而是开始从文件入口位置开始执行命令。文件必须是ELF格式。</p>
<p>xv6 shell使用以上四个system call来为用户执行程序。在shell进程的<code>main</code>中主循环先通过<code>getcmd</code>来从用户获取命令**（绝大部分命令本身就是独立的可执行文件）**，然后调用<code>fork</code>来运行一个和当前shell进程完全相同的子进程。父进程调用<code>wait</code>等待子进程<code>exec</code>执行完（在<code>runcmd</code>中调用<code>exec</code>）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sh.c */</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确认三个文件都已经打开</span></span><br><span class="line">  <span class="keyword">while</span>((fd = <span class="built_in">open</span>(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">      <span class="built_in">close</span>(fd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read and run input commands.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">getcmd</span>(buf, <span class="built_in">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">      buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">chdir</span>(buf<span class="number">+3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf<span class="number">+3</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">runcmd</span>(<span class="built_in">parsecmd</span>(buf));</span><br><span class="line">    <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-I-O-and-File-descriptors">1.2 I/O and File descriptors</h3>
<ul>
<li>
<p>file descriptor*：文件描述符，用来表示一个被内核管理的、可以被进程读/写的对象的一个整数，表现形式类似于字节流，通过打开文件、目录、设备等方式获得。一个文件被打开得越早，文件描述符就越小。</p>
<p>每个进程都拥有自己独立的文件描述符列表，其中0是标准输入，1是标准输	出，2是标准错误。shell将保证总是有3个文件描述符是可用的</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((fd = open(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>read</code>和<code>write</code>：形式<code>int write(int fd, char *buf, int n)</code>和<code>int read(int fd, char *bf, int n)</code>。从/向文件描述符<code>fd</code>读/写n字节<code>bf</code>的内容，返回值是成功读取/写入的字节数。每个文件描述符有一个offset，<code>read</code>会从这个offset开始读取内容，读完n个字节之后将这个offset后移n个字节，下一个<code>read</code>将从新的offset开始读取字节。<code>write</code>也有类似的offset</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* essence of cat program */</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read errot\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (write(<span class="number">1</span>, buf, n) != n)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>close</code>。形式是<code>int close(int fd)</code>，将打开的文件<code>fd</code>释放，使该文件描述符可以被后面的<code>open</code>、<code>pipe</code>等其他system call使用。</p>
<p>使用<code>close</code>来修改file descriptor table能够实现I/O重定向</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* implementation of I/O redirection,</span></span><br><span class="line"><span class="comment"> * more specifically, cat &lt; input.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// in the child process</span></span><br><span class="line">    close(<span class="number">0</span>);  <span class="comment">// this step is to release the stdin file descriptor</span></span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY); <span class="comment">// the newly allocated fd for input.txt is 0, since the previous fd 0 is released</span></span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>, argv); <span class="comment">// execute the cat program, by default takes in the fd 0 as input, which is input.txt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​	父进程的fd table将不会被子进程fd table的变化影响，但是文件中的offset将被	共享。</p>
<ul>
<li>
<p><code>dup</code>。形式是<code>int dup(int fd)</code>，复制一个新的<code>fd</code>指向的I/O对象，返回这个新fd值，两个I/O对象(文件)的offset相同</p>
<p>e.g.</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// outputs hello world问问 </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>dup</code>。形式是<code>int dup(int fd)</code>，复制一个新的<code>fd</code>指向的I/O对象，返回这个新fd值，两个I/O对象(文件)的offset相同</p>
<p>e.g.</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// outputs hello world</span></span><br></pre></td></tr></table></figure>
<p>除了<code>dup</code>和<code>fork</code>之外，其他方式<strong>不能</strong>使两个I/O对象的offset相同，比如同时<code>open</code>相同的文件</p>
</li>
</ul>
<h3 id="1-3-Pipes">1.3 Pipes</h3>
<ul>
<li>
<p>pipe：管道，暴露给进程的一对文件描述符，一个文件描述符用来读，另一个文件描述符用来写，将数据从管道的一端写入，将使其能够被从管道的另一端读出</p>
<p><code>pipe</code>是一个system call，形式为<code>int pipe(int p[])</code>，<code>p[0]</code>为读取的文件描述符，<code>p[1]</code>为写入的文件描述符</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* run the program wc with stdin connected to the read end of pipe, parent process able to communicate with child process */</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pipe</span>(p); <span class="comment">// read fd put into p[0], write fd put into p[1]</span></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">close</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dup</span>(p[<span class="number">0</span>]); <span class="comment">// make the fd 0 refer to the read end of pipe</span></span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">0</span>]); <span class="comment">// original read end of pipe is closed</span></span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">1</span>]); <span class="comment">// fd p[1] is closed in child process, but not closed in the parent process. 注意这里关闭p[1]非常重要，因为如果不关闭p[1]，管道的读取端会一直等待读取，wc就永远也无法等到EOF</span></span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">&quot;/bin/wc&quot;</span>, argv); <span class="comment">// by default wc will take fd 0 as the input, which is the read end of pipe in this case</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">0</span>]); <span class="comment">// close the read end of pipe in parent process will not affect child process</span></span><br><span class="line">    <span class="built_in">write</span>(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>); </span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">1</span>]); <span class="comment">// write end of pipe closed, the pipe shuts down</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xv6中的实现和上述的类似</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PIPE:</span><br><span class="line">pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line"><span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// in child process</span></span><br><span class="line">    close(<span class="number">1</span>); <span class="comment">// close stdout</span></span><br><span class="line">    dup(p[<span class="number">1</span>]); <span class="comment">// make the fd 1 as the write end of pipe</span></span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    runcmd(pcmd-&gt;left); <span class="comment">// run command in the left side of pipe |, output redirected to the write end of pipe</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// in child process</span></span><br><span class="line">    close(<span class="number">0</span>); <span class="comment">// close stdin</span></span><br><span class="line">    dup(p[<span class="number">0</span>]); <span class="comment">// make the fd 0 as the read end of pipe</span></span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    runcmd(pcmd-&gt;right); <span class="comment">//  run command in the right side of pipe |, input redirected to the read end of pipe</span></span><br><span class="line">&#125;</span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line">wait(<span class="number">0</span>); <span class="comment">// wait for child process to finish</span></span><br><span class="line">wait(<span class="number">0</span>); <span class="comment">// wait for child process to finish</span></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-4-File-system">1.4 File system</h3>
<p>xv6文件系统包含了<em>文件</em>(byte arrays)和<em>目录</em>(对其他文件和目录的引用)。目录生成了一个树，树从根目录<code>/</code>开始。对于不以<code>/</code>开头的路径，认为是是相对路径</p>
<ul>
<li><code>mknod</code>：创建设备文件，一个设备文件有一个major device #和一个minor device #用来唯一确定这个设备。当一个进程打开了这个设备文件时，内核会将<code>read</code>和<code>write</code>的system call重新定向到设备上。</li>
<li>一个文件的名称和文件本身是不一样的，文件本身，也叫<em>inode</em>，可以有多个名字，也叫<em>link</em>，每个link包括了一个文件名和一个对inode的引用。一个inode存储了文件的元数据，包括该文件的类型(file, directory or device)、大小、文件在硬盘中的存储位置以及指向这个inode的link的个数</li>
<li><code>fstat</code>。一个system call，形式为<code>int fstat(int fd, struct stat *st)</code>，将inode中的相关信息存储到<code>st</code>中。</li>
<li><code>link</code>。一个system call，将创建一个指向同一个inode的文件名。<code>unlink</code>则是将一个文件名从文件系统中移除，只有当指向这个inode的文件名的数量为0时这个inode以及其存储的文件内容才会被从硬盘上移除</li>
</ul>
<p>注意：Unix提供了许多在<strong>用户层面</strong>的程序来执行文件系统相关的操作，比如<code>mkdir</code>、<code>ln</code>、<code>rm</code>等，而不是将其放在shell或kernel内，这样可以使用户比较方便地在这些程序上进行扩展。但是<code>cd</code>是一个例外，它是在shell程序内构建的，因为它必须要改变这个calling shell本身指向的路径位置，如果是一个和shell平行的程序，那么它必须要调用一个子进程，在子进程里起一个新的shell，再进行<code>cd</code>，这是不符合常理的。</p>
<h2 id="Lecture-2-Operating-System-Organization">Lecture 2 Operating System Organization</h2>
<h3 id="2-1-User-mode-and-supervisor-mode">2.1 User mode and supervisor mode</h3>
<p>为了实现进程隔离，RISC-V CPU在硬件上提供3种执行命令的模式：<em>machine mode</em>, <em>supervisor mode</em>, <em>user mode</em>。</p>
<ol>
<li>machine mode的权限最高，CPU以machine mode启动，machine mode的主要目的是为了配置电脑，之后立即切换到supervisor mode。</li>
<li>supervisor mode运行CPU执行<em>privileged instructions</em>(特权指令)，比如中断管理、对存储页表地址的寄存器进行读写操作、执行system call。运行在supervisor mode也称为在<em>kernel space</em>中运行。</li>
<li>应用程序只能执行user mode指令，比如改变变量、执行util function。运行在user mode也称为在<em>user space</em>中运行。要想让CPU从user mode切换到supervisor mode，RISC-V提供了一个特殊的<code>ecall</code>指令，要想从supervisor mode切换到user mode，调用<code>sret</code>指令</li>
</ol>
<h3 id="2-2-Kernel-organization">2.2 Kernel organization</h3>
<p><em>monolithic kernel</em>：整个操作系统在kernel中，所有system call都在supervisor mode下运行。xv6是一个monolithic kernel</p>
<p><em>micro kernel</em>：将需要运行在supervisor mode下的操作系统代码压到最小，保证kernel内系统的安全性，将大部分的操作系统代码执行在user mode下。</p>
<p><img src="/images/6.S081notes-2.png" alt></p>
<p>如2.1所示，文件系统是一个user-level的进程，为其他进程提供服务，因此也叫做server</p>
<p>xv6 kernel source file如下所示</p>
<p><img src="/images/6.S081notes-3.png" alt></p>
<h3 id="2-3-Process">2.3 Process</h3>
<p>隔离的单元叫做进程，一个进程不能够破坏或者监听另外一个进程的内存、CPU、文件描述符，也不能破坏kernel本身。</p>
<p>为了实现进程隔离，xv6提供了一种机制让程序认为自己拥有一个独立的机器。一个进程为一个程序提供了一个私有的内存系统，或<em>address space</em>，其他的进程不能够读/写这个内存。xv6使用<em>page table</em>(页表)来给每个进程分配自己的address space，页表再将这些address space，也就是进程自己认为的虚拟地址(<em>virtual address</em>)映射到RISC-V实际操作的物理地址(<em>physical address</em>)</p>
<p><img src="/images/6.S081notes-4.png" alt></p>
<p>虚拟地址从0开始，往上依次是指令、全局变量、栈、堆。RISC-V上的指针是64位的，xv6使用低38位，因此最大的地址是238−1238−1=0x3fffffffff=MAXVA</p>
<p>进程最重要的内核状态：1. 页表 <code>p-&gt;pagetable</code> 2. 内核堆栈<code>p-&gt;kstack</code> 3. 运行状态<code>p-&gt;state</code>，显示进程是否已经被分配、准备运行/正在运行/等待IO或退出</p>
<p>每个进程中都有线程(<em>thread</em>)，是执行进程命令的最小单元，可以被暂停和继续</p>
<p>每个进程有两个堆栈：用户堆栈(<em>user stack</em>)和内核堆栈(<em>kernel stack</em>)。当进程在user space中进行时只使用用户堆栈，当进程进入了内核(比如进行了system call)使用内核堆栈</p>
<h3 id="2-4-Starting-the-first-process">2.4 Starting the first process</h3>
<p>RISC-V启动时，先运行一个存储于ROM中的bootloader程序<code>kernel.ld</code>来加载xv6 kernel到内存中，然后在machine模式下从<code>_entry</code>开始运行xv6。bootloader将xv6 kernel加载到0x80000000的物理地址中，因为前面的地址中有I/O设备</p>
<p>在<code>_entry</code>中设置了一个初始stack，<code>stack0</code>来让xv6执行<code>kernel/start.c</code>。在<code>start</code>函数先在machine模式下做一些配置，然后通过RISC-V提供的<code>mret</code>指令切换到supervisor mode，使program counter切换到<code>kernel/main.c</code></p>
<p><code>main</code>先对一些设备和子系统进行初始化，然后调用<code>kernel/proc.c</code>中定义的<code>userinit</code>来创建第一个用户进程。这个进程执行了一个<code>initcode.S</code>的汇编程序，这个汇编程序调用了<code>exec</code>这个system call来执行<code>/init</code>，重新进入kernel。<code>exec</code>将当前进程的内存和寄存器替换为一个新的程序(<code>/init</code>)，当kernel执行完毕<code>exec</code>指定的程序后，回到<code>/init</code>进程。<code>/init</code>(<code>user/init.c</code>)创建了一个新的console device以文件描述符0,1,2打开，然后在console device中开启了一个shell进程，至此整个系统启动了</p>
<h2 id="Lecture-3-Page-Tables">Lecture 3 Page Tables</h2>
<p>页表让每个进程都拥有自己独立的虚拟内存地址，从而实现内存隔离。</p>
<h3 id="3-1-Paging-Hardware">3.1 Paging Hardware</h3>
<p>xv6运行于Sv39 RISC-V，即在64位地址中只有最下面的39位被使用作为虚拟地址，其中底12位是页内偏移，高27位是页表索引，即4096字节(2^12^)作为一个page，一个进程的虚拟内存可以有 2^27^个page，对应到页表中就是2^27^个page table entry (PTE)。每个PTE有一个44位的physical page number (PPN)用来映射到物理地址上和10位flag，总共需要54位，也就是一个PTE需要8字节存储。即每个物理地址的高44位是页表中存储的PPN，低12位是页内偏移，一个物理地址总共由56位构成。</p>
<p><img src="/images/6.S081notes-5.png" alt></p>
<p>在实际中，页表并不是作为一个包含了2^27^个PTE的大列表存储在物理内存中的，而是采用了三级树状的形式进行存储，这样可以让页表分散存储。每个页表就是一页。第一级页表是一个4096字节的页，包含了512个PTE（因为每个PTE需要8字节），每个PTE存储了下级页表的页物理地址，第二级列表由512个页构成，第三级列表由512*512个页构成。因为每个进程虚拟地址的高27位用来确定PTE，对应到3级页表就是最高的9位确定一级页表PTE的位置，中间9位确定二级页表PTE的位置，最低9位确定三级页表PTE的位置。如下图所示。第一级根页表的物理页地址存储在<code>satp</code>寄存器中，每个CPU拥有自己独立的<code>satp</code></p>
<p><img src="/images/6.S081notes-6.png" alt></p>
<p>PTE flag可以告诉硬件这些相应的虚拟地址怎样被使用，比如<code>PTE_V</code>表明这个PTE是否存在，<code>PTE_R</code>、<code>PTE_W</code>、<code>PTE_X</code>控制这个页是否允许被读取、写入和执行，<code>PTE_U</code>控制user mode是否有权访问这个页，如果<code>PTE_U</code>=0，则只有supervisor mode有权访问这个页。</p>
<h3 id="3-2-Kernel-address-space">3.2 Kernel address space</h3>
<p>每个进程有一个页表，用于描述进程的用户地址空间，还有一个内核地址空间（所有进程共享这一个描述内核地址空间的页表）。为了让内核使用物理内存和硬件资源，内核需要按照一定的规则排布内核地址空间，以能够确定哪个虚拟地址对应自己需要的硬件资源地址。用户地址空间不需要也不能够知道这个规则，因为用户空间不允许直接访问这些硬件资源。</p>
<p>QEMU会模拟一个从0x80000000开始的RAM，一直到0x86400000。QEMU会将设备接口以控制寄存器的形式暴露给内核，这些控制寄存器在0x80000000以下。kernel对这些设备接口控制寄存器的访问是直接和这些设备而不是RAM进行交互的。</p>
<p><img src="/images/6.S081notes-7.png" alt></p>
<p>左边和右边分别是kernel virtual address和physical address的映射关系。在虚拟地址和物理地址中，kernel都位于<code>KERNBASE=0x80000000</code>的位置，这叫做直接映射。</p>
<p>用户空间的地址分配在free memory中</p>
<p>有一些不是直接映射的内核虚拟地址：</p>
<ul>
<li>trampoline page（和user pagetable在同一个虚拟地址，以便在user space和kernel space之间跳转时切换进程仍然能够使用相同的映射，真实的物理地址位于kernel text中的<code>trampoline.S</code>）</li>
<li>kernel stack page：每个进程有一个自己的内核栈kstack，每个kstack下面有一个没有被映射的guard page，guard page的作用是防止kstack溢出影响其他kstack。当进程运行在内核态时使用内核栈，运行在用户态时使用用户栈。<strong>注意</strong>：还有一个内核线程，这个线程只运行在内核态，不会使用其他进程的kstack，内核线程没有独立的地址空间。</li>
</ul>
<h3 id="3-3-Code-creating-an-address-space">3.3 Code: creating an address space</h3>
<p>xv6中和页表相关的代码在<code>kernel/vm.c</code>中。最主要的结构体是<code>pagetable_t</code>，这是一个指向页表的指针。<code>kvm</code>开头的函数都是和kernel virtual address相关的，<code>uvm</code>开头的函数都是和user virtual address相关的，其他的函数可以用于这两者</p>
<p>几个比较重要的函数：</p>
<ul>
<li><code>walk</code>：给定一个虚拟地址和一个页表，返回一个PTE指针</li>
<li><code>mappages</code>：给定一个页表、一个虚拟地址和物理地址，创建一个PTE以实现相应的映射</li>
<li><code>kvminit</code>用于创建kernel的页表，使用<code>kvmmap</code>来设置映射</li>
<li><code>kvminithart</code>将kernel的页表的物理地址写入CPU的寄存器<code>satp</code>中，然后CPU就可以用这个kernel页表来翻译地址了</li>
<li><code>procinit</code>(kernel/proc.c)为每一个进程分配(<code>kalloc</code>)kstack。<code>KSTACK</code>会为每个进程生成一个虚拟地址（同时也预留了guard pages)，<code>kvmmap</code>将这些虚拟地址对应的PTE映射到物理地址中，然后调用<code>kvminithart</code>来重新把kernel页表加载到<code>satp</code>中去。</li>
</ul>
<p>每个RISC-V <strong>CPU</strong>会把PTE缓存到*Translation Look-aside Buffer (TLB)*中，当xv6更改了页表时，必须通知CPU来取消掉当前的TLB，取消当前TLB的函数是<code>sfence.vma()</code>，在<code>kvminithart</code>中被调用</p>
<h3 id="3-4-Physical-memory-allocation-for-kernel">3.4 Physical memory allocation for kernel</h3>
<p>xv6对kernel space和PHYSTOP之间的物理空间在运行时进行分配，分配以页(4096 bytes)为单位。分配和释放是通过对空闲页链表进行追踪完成的，分配空间就是将一个页从链表中移除，释放空间就是将一页增加到链表中</p>
<p>kernel的物理空间的分配函数在<code>kernel/kalloc.c</code>中，每个页在链表中的元素是<code>struct run</code>，每个<code>run</code>存储在空闲页本身中。这个空闲页的链表<code>freelist</code>由spin lock保护，包装在<code>struct kmem</code>中。</p>
<ul>
<li><code>kinit()</code>：对分配函数进行初始化，将kernel结尾到PHYSTOP之间的所有空闲空间都添加到kmem链表中，这是通过调用<code>freerange(end, PHYSTOP)</code>实现的</li>
<li><code>freerange()</code>对这个范围内所有页都调用一次<code>kfree</code>来将这个范围内的页添加到<code>freelist</code>链表中</li>
</ul>
<h3 id="3-5-User-space-memory">3.5 User space memory</h3>
<p>每个进程有自己的用户空间下的虚拟地址，这些虚拟地址由每个进程自己的页表维护，用户空间下的虚拟地址从0到MAXVA</p>
<p>当进程向xv6索要更多用户内存时，xv6先用<code>kalloc</code>来分配物理页，然后向这个进程的页表增加指向这个新的物理页的PTE，同时设置这些PTE的flag</p>
<p><img src="/images/6.S081notes-8.png" alt></p>
<p>图3.4是一个进程在刚刚被<code>exec</code>调用时的用户空间下的内存地址，stack只有一页，包含了<code>exec</code>调用的命令的参数从而使<code>main(argc, argv)</code>可以被执行。stack下方是一个guard page来检测stack溢出，一旦溢出将会产生一个page fault exception</p>
<p><code>sbrk</code>是一个可以让进程增加或者缩小用户空间内存的system call。<code>sbrk</code>调用了<code>growproc</code>(kernel/proc.c)来改变<code>p-&gt;sz</code>从而改变<strong>heap</strong>中的program break，<code>growproc</code>调用了<code>uvmalloc</code>和<code>uvmdealloc</code>，前者调用了<code>kalloc</code>来分配物理内存并且通过<code>mappages</code>向用户页表添加PTE，后者调用了<code>kfree</code>来释放物理内存</p>
<h3 id="3-6-Code-exec">3.6 Code: exec</h3>
<p><code>exec</code>是一个system call，为以ELF格式定义的文件系统中的可执行文件创建用户空间。</p>
<p><code>exec</code>先检查头文件中是否有ELF_MAGIC来判断这个文件是否是一个ELF格式定义的二进制文件，用<code>proc_pagetable</code>来为当前进程创建一个还没有映射的页表，然后用<code>uvmalloc</code>来为每个ELF segment分配物理空间并在页表中建立映射，然后用<code>loadseg</code>来把ELF segment加载到物理空间当中。注意<code>uvmalloc</code>分配的物理内存空间可以比文件本身要大。</p>
<p>接下来<code>exec</code>分配user stack，它仅仅分配一页给stack，通过<code>copyout</code>将传入参数的string放在stack的顶端，在ustack的下方分配一个guard page</p>
<p>如果<code>exec</code>检测到错误，将跳转到<code>bad</code>标签，释放新创建的<code>pagetable</code>并返回-1。<code>exec</code>必须确定新的执行能够成功才会释放进程旧的页表(<code>proc_freepagetable(oldpagetable, oldsz)</code>)，否则如果system call不成功，就无法向旧的页表返回-1</p>
<h3 id="3-7-Real-world">3.7 Real world</h3>
<p>xv6将kernel加载到0x8000000这一RAM物理地址中，但是实际上很多RAM的物理地址都是随机的，并不一定存在0x8000000这个地址</p>
<p>实际的处理器并不一定以4096bytes为一页，而可能使用各种不同大小的页</p>
<h2 id="Lecture-4-RISC-V-calling-convention">Lecture 4 RISC-V calling convention</h2>
<h3 id="4-1-ISA-Assembly-Language">4.1 ISA &amp; Assembly Language</h3>
<p>ISA: Instruction Set</p>
<p>C -&gt; Assembly(.S/.asm) -&gt; binary (object.o)</p>
<p>汇编语言没有明确的workflow，只是一行行指令</p>
<p>汇编语言是基于寄存器进行操作的，而不是基于内存操作</p>
<p>RISC-V vs x86：</p>
<ul>
<li>RISC-V：精简指令集，指令更少，更加简单，唯一开源的ISA。ARM也是RISC(Reduced Instruction Set Chip)</li>
<li>x86：复杂指令集，指令很多并且可以实现复杂功能</li>
</ul>
<p>RISC-V assembly常用指令:</p>
<p><a target="_blank" rel="noopener" href="https://web.eecs.utk.edu/~smarz1/courses/ece356/notes/assembly/">https://web.eecs.utk.edu/~smarz1/courses/ece356/notes/assembly/</a></p>
<ul>
<li><code>ld/lb/lw rd, 8(rs)</code>：将*(rs+8)的值写入到rd寄存器，<code>lb</code>=load byte, <code>ld</code>=load double word, <code>lw</code>=load word</li>
<li><code>sd/sb/sw rd, 8(rs)</code>：将(rd)的值写入到rs+8地址上</li>
<li><code>add rd, rs1, rs2</code>：将 <code>rs1</code> 寄存器中的<strong>值</strong>和 <code>rs2</code> 寄存器中的<strong>值</strong>相加，然后把结果存放到 <code>rd</code> 寄存器中</li>
<li><code>addi rd, rs1, int</code>: 将 <code>rs1</code> 寄存器中的<strong>值</strong>和指令中包含的<strong>立即数(int)</strong> 相加，结果存放到 <code>rd</code> 寄存器中</li>
</ul>
<h3 id="4-2-Calling-convention">4.2 Calling convention</h3>
<p>调用约定(calling convention)是规定子过程如何获取参数以及如何返回的方案，调用约定一般规定了</p>
<ul>
<li>
<p>参数、返回值、返回地址等放置的位置（寄存器、栈或存储器）</p>
<p>RISC-V寄存器通过寄存器而非栈来传递函数参数，a0-a7是int参数，fa0-fa7是float参数</p>
</li>
<li>
<p>如何将调用子过程的准备工作与恢复现场的工作划分到调用者(caller)与被调用者(callee)身上</p>
</li>
</ul>
<p><img src="/images/6.S081notes-9.png" alt></p>
<p>小于一个指针字(RISCV64中是8字节，RISCV32是4字节)的参数传入时将参数放在寄存器的最低位，因为RISC-V是小端系统，当2个指针字的参数传入时，低位的1个指针字放在偶数寄存器，比如a0上，高位的1个指针字放在奇数寄存器，比如a1上。当高于2个指针字的参数传入时以引用的方式传入。<code>struct</code>参数没有传到寄存器的部分将以栈的方式传入，<code>sp</code>栈指针将指向第一个没有传入到寄存器的参数。</p>
<p>从函数返回的值，如果是整数将放在a0和a1中，如果是小数将放置在fa0和fa1寄存器中。对于更大的返回值，将放置在内存中，caller开辟这个内存，并且把指向这个内存的指针作为第一个参数传递给callee</p>
<p>由caller保存的寄存器不会在函数调用之间被保存，又名易失性寄存器，如果要在过程调用后恢复该值，则调用方有责任将这些寄存器压入堆栈或复制到其他位置，而callee保存的寄存器会被保存，称为非易失性寄存器，可以期望这些寄存器在被调用者返回后保持相同的值。比如函数A调用了函数B，所有函数A保存的寄存器在函数B被调用后可以被B重写覆盖</p>
<h3 id="4-3-Stack">4.3 Stack</h3>
<p><img src="/images/6.S081notes-10.png" alt></p>
<p>栈从高地址向低地址增长，每个大的box叫一个stack frame（栈帧），栈帧由函数调用来分配，每个栈帧大小不一定一样，但是栈帧的最高处一定是return address</p>
<p>sp是stack pointer，用于指向栈顶（低地址），保存在寄存器中</p>
<p>fp是frame pointer，用于指向当前帧底部（高地址），保存在寄存器中，同时每个函数栈帧中保存了调用当前函数的函数（父函数）的fp（保存在to prev frame那一栏中）</p>
<p>这些栈帧都是由编译器编译生成的汇编文件生成的</p>
<h2 id="Lecture-5-Traps">Lecture 5 Traps</h2>
<h3 id="5-0-trap">5.0 trap</h3>
<p>3种可能的情况使得CPU暂停对正常指令的执行：1. syscall，移交给kernel 2. exception，指令执行了非法操作 3. 设备中断。以上情况合并称为<em>trap</em>。</p>
<p>trap应该对于被打断的指令是透明的，也就是说被打断的指令不应该知道这个地方产生了trap，产生trap之后现场应该得以恢复并继续执行被打断的指令。</p>
<p>xv6对trap的处理分为四个阶段：1. RISC-V CPU的硬件的一些动作 2. 汇编文件为了kernel C文件进行的一些准备 3. 用C实现的trap handler 4. system call / device-driver service routine</p>
<p>通常对于user space的trap、kernel space的trap和计时器中断会有不同的trap handler</p>
<h3 id="5-1-RISC-V-trap-machinery">5.1 RISC-V trap machinery</h3>
<p>RISC-V CPU有一系列的控制寄存器可以通知kernel发生了trap，也可以由kernel写入来告诉CPU怎样处理trap</p>
<ul>
<li>
<p><code>stvec</code>：trap handler的地址，由kernel写入</p>
</li>
<li>
<p><code>sepc</code>：保存trap发生时的现场program counter，因为接下来<code>pc</code>要被取代为<code>stvec</code>。<code>sret</code>是从trap回到现场的指令，将<code>sepc</code>写回到<code>pc</code></p>
</li>
<li>
<p><code>scause</code>：一个trap产生的原因代码，由CPU写入</p>
</li>
<li>
<p><code>sscratch</code>：放在trap handler的最开始处</p>
</li>
<li>
<p><code>sstatus</code>：控制设备中断是否被开启，如果<code>sstatus</code>中的SIE位被清除，则RISC-V将推迟设备中断。SPP位指示这个trap是在user space中产生的还是在kernel space产生的，并将控制<code>sret</code>回到什么模式</p>
<p>以上寄存器只在supervisor模式下发生的trap被使用</p>
</li>
</ul>
<p>当发生除了计时器中断以外的其他类型的trap时，RISC-V将执行以下步骤：</p>
<ol>
<li>如果trap是一个设备产生的中断，而SIE又被清除的情况下，不做下方的任何动作</li>
<li>清除SIE来disable一切中断</li>
<li>把<code>pc</code>复制到<code>sepc</code></li>
<li>把当前的模式(user / supervisor)保存到SPP</li>
<li>设置<code>scause</code>寄存器来指示产生trap的原因</li>
<li>将当前的模式设置为supervisor</li>
<li>将<code>stvec</code>的值复制到<code>pc</code></li>
<li>开始执行<code>pc</code>指向的trap handler的代码</li>
</ol>
<p>注意CPU并没有切换到kernel页表，也没有切换到kernel栈</p>
<h3 id="5-2-Traps-from-user-space">5.2 Traps from user space</h3>
<p>当user space中发生trap 时，会将<code>stvec</code>的值复制到<code>pc</code>，而此时<code>stvec</code>的值是<code>trampoline.S</code>中的<code>uservec</code>，因此跳转到<code>uservec</code>，先保存一些现场的寄存器，恢复kernel栈指针、kernel page table到<code>satp</code>寄存器，再跳转到<code>usertrap</code>(kernel/trap.c)trap handler，然后返回<code>usertrapret</code>(kernel/trap.c)，跳回到kernel/trampoline.S，最后用<code>userret</code>(kernel/trampoline.S)通过<code>sret</code>跳回到user space</p>
<p>RISC-V在trap中不会改变页表，因此user page table必须有对<code>uservec</code>的mapping，<code>uservec</code>是<code>stvec</code>指向的trap vector instruction。<code>uservec</code>要切换<code>satp</code>到kernel页表，同时kernel页表中也要有和user页表中对<code>uservec</code>相同的映射。RISC-V将<code>uservec</code>保存在<em>trampoline</em>页中，并将<code>TRAMPOLINE</code>放在kernel页表和user页表的相同位置处（MAXVA)</p>
<p>当<code>uservec</code>开始时所有的32个寄存器都是trap前代码的值，但是<code>uservec</code>需要对某些寄存器进行修改来设置<code>satp</code>，可以用<code>sscratch</code>和<code>a0</code>的值进行交换，交换之前的<code>sscratch</code>中是指向user process的<code>trapframe</code>的地址，<code>trapframe</code>中预留了保存所有32个寄存器的空间。<code>p-&gt;trapframe</code>保存了每个进程的<code>TRAPFRAME</code>的物理空间从而让kernel页表也可以访问该进程的trapframe</p>
<p>当交换完<code>a0</code>和<code>sscratch</code>之后，<code>uservec</code>可以通过<code>a0</code>把所有当前寄存器的值保存到trapframe中。由于当前进程的trapframe已经保存了当前进程的kernel stack、当前CPU的hartid、<code>usertrap</code>的地址、kernel page table的地址等，<code>uservec</code>需要获取这些值，然后切换到kernel p问问  我  agetable，调用<code>usertrap</code></p>
<p><code>usertrap</code>主要是判断trap产生的原因并进行处理，然后返回。因为当前已经在kernel里了，所以这时候如果再发生trap，应该交给<code>kernelvec</code>处理，因此要把<code>stvec</code>切换为<code>kernelvec</code>。如果trap是一个system call，那么<code>syscall</code>将被调用，如果是设备中断，调用<code>devintr</code>，否则就是一个exception，kernel将杀死这个出现错误的进程</p>
<p>回到user space的第一步是调用<code>usertrapret()</code>，这个函数将把<code>stvec</code>指向<code>uservec</code>，从而当回到user space再出现trap的时候可以跳转到<code>uservec</code>，同时设置<code>p-&gt;trapframe</code>的一些值为下一次trap作准备，比如设置<code>p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE</code>。清除<code>SPP</code>为从而使得调用<code>sret</code>后能够回到user mode。设置回到user space后的program counter为<code>p-&gt;trapframe-&gt;epc</code>，最后调用跳转到TRAMPOLINE页上的<code>userret</code>回到tram2poline.S，加载user page table。<code>userret</code>被<code>userrapret</code>调用返回时a0寄存器中保存了TRAPFRAME，因此可以通过这个TRAPFRAME地址来恢复之前所有寄存器的值(包括a0)，最后把TRAPFRAME保存在sscratch中，用<code>sret</code>回到user space</p>
<h3 id="5-3-Calling-system-calls">5.3 Calling system calls</h3>
<p>user调用<code>exec</code>执行system call的过程：把给<code>exec</code>使用的参数放到a0和a1寄存器中，把system call的代码(SYS_exec)放到a7寄存器中，<code>ecall</code>指令将陷入内核中（通过usys.pl中的entry)。<code>ecall</code>的效果有三个，包括将CPU从user mode切换到supervisor mode、将<code>pc</code>保存到<code>epc</code>以供后续恢复、将<code>uservec</code>设置为<code>stvec</code>，并执行<code>uservec</code>、<code>usertrap</code>，然后执行<code>syscall</code>。kernel trap code将把寄存器的值保存在当前进程的trapframe中。syscall将把trapframe中的a7寄存器保存的值提取出来，索引到<code>syscalls</code>这个函数数列中查找对应的syscall种类，并进行调用，然后把返回值放置在<code>p-&gt;trapframe-&gt;a0</code>中，如果执行失败，就返回-1。</p>
<p>syscall的argument可以用<code>argint</code>、<code>argaddr</code>、<code>argfd</code>等函数从内存中取出</p>
<h3 id="5-4-Traps-from-kernel-space">5.4 Traps from kernel space</h3>
<p>当执行kernel code发生CPU trap的时候，<code>stvec</code>是指向<code>kernelvec</code>的汇编代码的。<code>kernelvec</code>将寄存器的值保存在被中断的kernel thread的栈里而不是trapframe里，这样当trap需要切换kernel thread时，再切回来之后还可以从原先的thread栈里找到之前的寄存器值。</p>
<p>保存完寄存器之后，跳转到<code>kerneltrap</code>这个trap handler。<code>kerneltrap</code>可以对设备中断和exception这两种trap进行处理。如果是设备中断，调用<code>devintr</code>进行处理，如果是exception就panic，如果是因为计时器中断，就调用<code>yield</code>让其他kernel thread运行</p>
<p>最后返回到<code>kernelvec</code>中，<code>kernelvec</code>将保存的寄存器值从堆栈中弹出，执行<code>sret</code>，将<code>sepc</code>复制到<code>pc</code>来执行之前被打断的kernel code</p>
<h2 id="Lecture-6-Interrupts">Lecture 6 Interrupts</h2>
<p>设备会产生中断，xv6处理设备中断的代码位于kernel/trap.c中的<code>devintr</code>。</p>
<p>进程的内核态中执行<em>top half</em>，中断时间中执行<em>bottom half</em>。top half是通过<code>read</code>或<code>write</code>这样的system call来进行调用的，从而能让这个设备执行I/O操作。当设备执行完I/O操作之后，将产生一个设备中断，这个设备驱动的interrupt handler作为bottom half执行相应的操作。interrupt handler中没有任何用户进程的上下文，因此无法进行<code>copyin</code>或<code>copyout</code>，只有top half才能和用户进程进行交互。</p>
<ul>
<li><code>PLIC</code>: Platform-Level Interrupt Controller，负责对从外部设备产生的中断进行管理</li>
<li><code>CLINT</code>: Core-Local Interrupter，负责定时器相关的中断</li>
</ul>
<p><img src="/images/6.S081notes-11.png" alt></p>
<h3 id="6-1-Console-input">6.1 Console input</h3>
<p>console driver(kernel/console.c)是一个设备驱动，通过UART串口接受输入的符号。用户进程通过<code>read</code> system call来从console中一行行读取输入</p>
<p>xv6中使用的UART是QEMU模拟的16550芯片。UART硬件对于进程来说是一组<em>memory-mapped</em>寄存器，即RISC-V上有一些物理地址是直接和UART设备相连的。UART的地址从0x10000000或<code>UART0</code>开始，每个UART控制寄存器的大小为1字节，其位置定义在kernel/uart.c中。</p>
<ul>
<li><code>LSR</code>寄存器：line status register，用来指示输入的字节是否准备好被用户进程读取</li>
<li><code>RHR</code>寄存器：receive holding register，用来放置可以被用户进程读取的字节。当RHR中的一个字节被读取时，UART硬件将其从内部的FIFO硬盘中删除，当FIFO中为空时，<code>LSR</code>寄存器被置0</li>
<li><code>THR</code>寄存器：transmit holding register，当用户进程向<code>THR</code>写入一个字节时，UART将传输这个字节</li>
</ul>
<p>xv6的<code>main</code>函数将调用<code>consoleinit</code>来初始化UART硬件，使得UART硬件在接收到字节或传输完成一个字节时发出中断</p>
<p>xv6 shell程序通过<code>user/init.c</code>开启的文件描述符来从console读取字节（在while循环中调用<code>getcmd</code>，在其中调用<code>gets</code>，再调用<code>read</code>system call）。在kernel中调用<code>consoleread</code>，等待输入完毕之后的中断，然后将输入缓存在<code>cons.buf</code>中，将输入<code>either_copyout</code>到user space后返回用户进程。如果用户没有输入完整的一行，则读取进程将在<code>sleep</code>system call中等待。</p>
<p>当用户输入了一个字符后，UART硬件将产生一个中断，这个终端将触发xv6进入trap。trap handler将调用<code>devintr</code>来通过<code>scause</code>寄存器判断是外部设备触发了这个中断，然后硬件将调用PLIC来判断是哪个外部设备触发的这个中断，如果是UART触发的，<code>devintr</code>将调用<code>uartintr</code>。<code>uartintr</code>将读取从UART硬件中写入的字符然后将其传送给<code>consoleintr</code>，<code>consoleintr</code>将积累这些字符直到整行都已经被读取，然后将唤醒仍在<code>sleep</code>的<code>consoleread</code>。当<code>consoleread</code>被唤醒后，将这一行命令复制给user space然后返回。</p>
<p>RISC-V对中断的支持：</p>
<p><code>SIE</code>(supervisor interrupt enable) 寄存器用来控制中断，其中有一位是控制外部设备的中断（SEIE），一位控制suffer interrupt(一个CPU向另外一个CPU发出中断)(SSIE)，一位控制定时器中断(STIE)</p>
<p><code>SSTATUS</code>(supervisor status)寄存器，对某一个特定的CPU核控制是否接收寄存器，在kernel/riscv.h中的<code>intr_on</code>被设置</p>
<p><code>SIP</code>(supervisor interrupt pending)寄存器，可以观察这个寄存器来判断有哪些中断在pending</p>
<p>case study:</p>
<p>用户在键盘上输入了一个字符l，这个l通过键盘被发送到UART，然后通过PLIC发送到CPU的一个核，这个核产生中断，跑到<code>devintr</code>，<code>devintr</code>发现是来自UART的，调用<code>uartintr</code>，调用<code>uartgetc()</code>通过<code>RHR</code>寄存器来获取这个字符，然后调用<code>consoleintr</code>，判断这个字符是否是特殊字符(backspace等)，如果不是则将这个字符通过<code>consputc(c)</code>echo回给user，然后将其存储在<code>cons.buf</code>中，当发现整行已经输入完成后(<code>c=='\n' || c ==C('D'))</code>)，唤醒<code>consoleread()</code></p>
<h3 id="6-2-Console-output">6.2 Console output</h3>
<p>对console上的文件描述符进行<code>write</code>system call，最终到达kernel/uart.c的<code>uartputc</code>函数。输出的字节将缓存在<code>uart_tx_buf</code>中，这样写入进程就不需要等待UART硬件完成字节的发送，只要当这个缓存区满了的情况下<code>uartputc</code>才会等待。当UART完成了一个字符的发送之后，将产生一个中断，<code>uartintr</code>将调用<code>uartstart</code>来判断设备是否确实已经完成发送，然后将下一个需要发送的字符发送给UART。因此让UART传送多个字符时，第一个字符由<code>uartputc</code>对<code>uartstart</code>的调用传送，后面的字符由<code>uartintr</code>对<code>uartstart</code>的调用进行传送</p>
<p><em>I/O concurrency</em>：设备缓冲和中断的解耦，从而让设备能够在没有进程等待读入的时候也能让console driver处理输入，等后面有进程需要读入的时候可以不需要等待。同时进程也可以不需要等待设备而直接写入字符到缓冲区。</p>
<p>在<code>consoleread</code>和<code>consoleintr</code>中调用了<code>acquire</code>来获取一个锁，从而保护当前的console driver，防止同时期其他进程对其的访问造成的干扰。</p>
<h3 id="6-3-Timer-interrupts">6.3 Timer interrupts</h3>
<p>xv6用计时器中断来在线程间切换，<code>usertrap</code>和<code>kerneltrap</code>中的<code>yield</code>也会导致这种进程切换。RISC-V要求定时器中断的handler放在machine mode而不是supervisor mode中，而machine mode下是没有paging的，同时有另外一套完全独立的控制寄存器，因此不能将计时器中断的handler放在trap机制中执行。</p>
<p><code>kernel/start.c</code>（在<code>main</code>之前）运行在machine mode下，<code>timerinit()</code>在<code>start.c</code>中被调用，用来配置CLINT(<em>core-local interruptor</em>)从而能够在一定延迟之后发送一个中断，并设置一个类似于trapframe的scratch area来帮助定时器中断handler将寄存器和CLINT寄存器的地址保存到里面，最终<code>start</code>设置<code>timervec</code>到<code>mtvec</code>(<em>machine-mode trap handler</em>)中使得在machine mode下发生中断后跳转到<code>timervec</code>然后enable定时器中断。</p>
<p>由于定时器中断可能在任意时间点发生，包括kernel在执行关键的操作时，无法强制关闭定时器中断，因此定时器中断的发生不能够影响这些被中断的操作。解决这个问题的方法是定时器中断handler让RISC-V CPU产生一个&quot;software interrupt&quot;然后立即返回，software interrupt以正常的trap机制被送到kernel中，可以被kernel禁用。</p>
<p>timervec<code>是一组汇编指令，将一些寄存器保存在scratch area中，告知CLINT产生下一次定时器中断的时间，让RISC-V产生一个software interrupt，恢复寄存器并返回到trap.c中，判断</code>which_dev==2<code>为定时器中断后调用</code>yield()</p>
<h3 id="6-4-Real-world">6.4 Real world</h3>
<p>计时器中断将会通过调用<code>yield</code>进行强制的线程切换从而使CPU能够在各个内核线程之间均匀分配时间。</p>
<p>UART是通过对UART控制寄存器一个字节一个字节读取来获取数据的，这种方式叫做<em>programmed I/O</em>，因为是软件控制了数据的I/O，缺点是速度比较慢。DMA(<em>Directed Memory Access</em>)直接向RAM写入和读取数据，速度很快。现代的硬盘和网卡驱动使用DMA。</p>
<p>由于中断非常耗时，因此可以用一些技巧来减少中断。1. 用一个中断来处理很多一段时间内的事件。 2. 彻底禁止设备的中断，让CPU定时去检查这些设备是否有任务需要处理，这种技巧叫做<em>polling</em></p>
<h2 id="Lecture-7-Locking">Lecture 7 Locking</h2>
<p>多核CPU同时对某个共享的数据结构进行读写操作可能会发生冲突，因此需要<em>concurrency control</em>，即<em>锁</em>。锁提供了一种互斥机制，一段时间内只有一个CPU才能拥有这个锁，如果一个锁和一个被共享的数据结构联系起来，那么这个数据结构一次只能被一个CPU使用</p>
<h3 id="7-1-Race-conditions">7.1 Race conditions</h3>
<p>kernel allocator中有一个<code>free</code>链表用来指示当前空闲待分配的内存，<code>kalloc()</code>将一页内存从<code>free</code>中弹出，<code>kfree()</code>将一页内存压入<code>free</code>。这个<code>free</code>链表被两个CPU的两个不同进程共享，如下图所示</p>
<p><img src="/images/6.S081notes-12.png" alt></p>
<p><em>race condition</em>：一个内存地址同时被至少一个写入操作访问，会造成bug</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">list</span> =</span> <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">listlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span> <span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">l</span>;</span></span><br><span class="line">    l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">    l-&gt;data = data;</span><br><span class="line">    acquire(&amp;listlock);</span><br><span class="line">    <span class="comment">// critical section</span></span><br><span class="line">    l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span> = l;</span><br><span class="line">    release(&amp;listlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>acquire</code>和<code>release</code>之间的代码叫做<em>critical section</em>。</p>
<p>当两个进程同时要求一个相同的锁时，这两个进程发生冲突，xv6对进程锁冲突没有做预防举措，但是更复杂的其他的kernel对此有实现。</p>
<p>注意<code>acquire</code>和<code>release</code>的位置很重要，不要包围不必要的代码，否则会降低程序运行效率。</p>
<h3 id="7-2-Code-Locks">7.2 Code: Locks</h3>
<p>xv6有两种锁：spinlock和sleep-lock。spinlock的代码位于kernel/spinlock.h的<code>struct spinlock</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>locked</code>为0时说明这个锁是可以acquire的。</p>
<p><code>acquire</code>中需要让类似于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lk-&gt;locked == <span class="number">0</span>)</span><br><span class="line">    lk-&gt;locked = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这样的逻辑原子化，否则当两个不同的进程同时执行到上面的判断条件时，可能会同时获取这个锁。RISC-V是通过<code>amoswap r, a</code>来实现的，它将<code>a</code>内存地址中的内容和<code>r</code>寄存器中的内容互换。在<code>acquire</code>中，通过一个对<code>amoswap</code>的包装函数<code>__sync_lock_test_and_set(&amp;lk-&gt;locked, 1)</code>来实现这个原子操作，这个函数的<strong>返回值</strong>是<code>lk-&gt;locked</code>的旧的值(被换下来的值)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>通过while不断尝试将1和<code>&amp;lk-&gt;locked</code>互换(spinning)，当原先的<code>lk-&gt;locked</code>是0时跳出循环，这个锁被取得，否则当原先的<code>lk-&gt;locked</code>是1时不会跳出循环，并且<code>lk-&gt;locked</code>和1互换还是1，不会改变它的状态。</p>
<p><code>release</code>是<code>acquire</code>的反向操作，先将<code>lk-&gt;cpu</code>清零。然后调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="comment">// s1 = &amp;lk-&gt;locked</span></span><br><span class="line"><span class="comment">// amoswap.w zero, zero, (s1)</span></span><br></pre></td></tr></table></figure>
<p>将<code>lk-&gt;locked</code>置0，这也是一个原子操作。</p>
<p>由于编译器有时候为了性能优化会重新排列代码的执行顺序，对于顺序执行的代码来说，这种重新排列顺序并不会改变代码执行的结果，但是对于并发执行的代码，则可能改变结果，因此需要在<code>acquire</code>和<code>release</code>中用<code>__sync_synchronize()</code>来保证CPU和编译器不进行重新排列顺序。<code>__sync_synchronize()</code>是一个barrier，任何在这一行代码之前的代码都不能reorder到这一行代码的后面。</p>
<h3 id="7-3-Deadlocks-and-lock-ordering">7.3 Deadlocks and lock ordering</h3>
<p>如果一块代码需要同时拥有多个锁，那么应该让其他需要相同锁的进程按照相同的顺序acquire这些锁，否则可能出现死锁。比如进程1和2都需要锁A和锁B，如果进程1先acquire了锁A，进程2acquire了锁B，那么接下来进程1需要acquire锁B，进程2需要acquire锁A，但是这两个都不能acquire到也无法release各自的锁，就会出现死锁。</p>
<p>由于<code>sleep</code>在xv6中的机制，xv6中有很多长度为2的lock-order。比如<code>consoleintr</code>中要求先获得<code>cons.lock</code>，当整行输入完毕之后再唤醒等待输入的进程，这需要获得睡眠进程的锁。xv6的文件系统中有一个很长的lock chain，如果要创建一个文件需要同时拥有文件夹的锁、新文件的inode的锁、磁盘块缓冲区的锁、磁盘驱动器的<code>vdisk_lock</code>的锁以及调用进程的<code>p-&gt;lock</code>的锁</p>
<p><img src="/images/6.S081notes-13.png" alt></p>
<p>除了<code>lock ordering</code>之外，锁和中断的交互也可能造成死锁。比如当<code>sys_sleep</code>拥有<code>tickslock</code>时，发生定时器中断，定时器中断的handler也需要acquire <code>tickslock</code>，就会等待<code>sys_sleep</code>释放，但是因为在中断里面，只要不从中断返回<code>sys_sleep</code>就永远无法释放，因此造成了死锁。对这种死锁的解决方法是：如果一个中断中需要获取某个特定的<code>spinlock</code>，那么当CPU获得了这个<code>spinlock</code>之后，该中断必须被禁用。xv6的机制则更加保守：当CPU获取了任意一个<code>lock</code>之后，将disable掉这个CPU上的所有中断（其他CPU的中断保持原样）。当CPU不再拥有<code>spinlock</code>时，将通过<code>pop_off</code>重新使能中断</p>
<h3 id="7-4-Sleep-locks">7.4 Sleep locks</h3>
<p>spinlock的两个缺点：1. 如果一个进程拥有一个锁很长时间，另外一个企图acquire的进程将一直等待。2. 当一个进程拥有锁的时候，不允许把当前使用的CPU资源切换给其他线程，否则可能导致第二个线程也acquire这个线程，然后一直无法切回到原来的线程，无法release锁，从而导致死锁。</p>
<p>xv6提供了一种<em>sleep-locks</em>，可以在试图<code>acquire</code>一个被拥有的锁时<code>yield</code> CPU。spin-lock适合短时间的关键步骤，sleep-lock适合长时间的锁。</p>
<h3 id="7-5-RCU">7.5 RCU</h3>
<p>RCU(Read-Copy Update)是一种能让多个读进程对链表进行同时读取，并让一个写进程同时对链表进行写入修改操作的机制，这种机制避免了进程进行读/写操作都需要获取锁而造成的锁竞争问题，适用于大量进程同时对链表结构进行读取的操作。</p>
<p>基本原理是：写进程在写入某一个链表中的节点时，比如</p>
<p>head-&gt;E1-&gt;E2-&gt;E3-&gt;nil</p>
<p>试图修改E2-&gt;content，则不直接修改E2-&gt;content，因为在修改E2-&gt;content的过程中可能会有别的进程在读，此时可能读入写了一半的内容，我们希望一个读进程读取的内容要么是修改之前的，要么是修改之后的，而不是修改一半的内容。写进程的操作是</p>
<ol>
<li>lock，防止其他写进程同时进行写入</li>
<li>E = alloc()，新分配一个element</li>
<li>E-&gt;next = E2-&gt;next，此时同时有2个element指向E3，但是其他读进程在读的时候还是读取的是旧的E2</li>
<li>E-&gt;content = new_content</li>
<li>E1-&gt;next = E，此时其他读进程在读的时候是新的E2，这是一个原子操作</li>
<li>unlock</li>
</ol>
<p>由于编译器有时候为了优化会将2 3 4 5等步骤打乱，因此需要在第5步之前设置memory barrier，即只有在2 3 4均完成的情况下才能执行第5步</p>
<p>同时需要释放原先的E2，但是由于可能很多读进程已经获取了对原先E2的指针，必须等待这些读进程读取完毕不再使用E2才能将原先的E2释放掉，这是通过以下规则实现的：</p>
<ol>
<li>所有的读进程不能够在进行context switch时拥有着对RCU-protected data的指针，也就是说在读进程读完E2之前，不能yield CPU</li>
<li>写进程需要等到所有的CPU都进行了一次context switch才能释放掉原先的数据，也就是E2(通过<code>synchronize_rcu()</code>实现)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list reader using RCU interface</span></span><br><span class="line">rcu_read_lock(); <span class="comment">// 设置flag防止context switch</span></span><br><span class="line">e = head;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">    e = rcu_dereference(e); <span class="comment">// 获取对e的指针</span></span><br><span class="line">    a = e-&gt;content;</span><br><span class="line">    e = e-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock(); <span class="comment">// 可以开始context switch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// list writer using RCU interface, replacing head</span></span><br><span class="line">acquire(lock);  <span class="comment">// normal spin lock</span></span><br><span class="line">old = head;     </span><br><span class="line">e = alloc();</span><br><span class="line">e-&gt;content = new_content;</span><br><span class="line">e-&gt;next = head-&gt;next;</span><br><span class="line">rcu_assign_pointer(&amp;head, e); <span class="comment">// commit the writes</span></span><br><span class="line">release(lock);</span><br><span class="line"></span><br><span class="line">synchronize_rcu(); <span class="comment">// wait untill all cpus have context switched, meaning that no reader can hold the pointer to old head</span></span><br><span class="line"><span class="built_in">free</span>(old);</span><br></pre></td></tr></table></figure>
<h2 id="Lecture-8-Scheduling">Lecture 8 Scheduling</h2>
<p>由于操作系统需要同时运行的进程的数量可能大于电脑CPU的数量，因此需要一种让进程time share CPU的机制，理想情况下这种机制对于用户进程应该是<strong>透明</strong>的，即让每个进程都认为自己拥有一个单独的虚拟CPU</p>
<p>线程：一个串行的指令执行</p>
<p>xv6的kernel thread支持共享内存，user process不支持</p>
<h3 id="8-1-Multiplexing">8.1 Multiplexing</h3>
<p>xv6在2种情况下在进程之间切换从而实现multiplexing。1. <code>sleep</code>/<code>wakeup</code>机制：进程等待设备或I/O、等待子进程退出、在<code>sleep</code>sys call中等待 2. 周期性强迫一个进程进行切换，防止一个进程占用过长时间。</p>
<p><img src="/images/6.S081notes-14.png" alt></p>
<h3 id="8-2-Context-Switching">8.2 Context Switching</h3>
<p>进程的上下文切换涉及到用户空间和内核空间之间的来回转换。当进程需要切换时，首先通过system call或中断陷入内核态，进入该进程的内核线程，然后将<strong>内核线程</strong>的上下文（注意不是用户进程的上下文，用户进程的上下文已经保存在了trapframe里面）切换到当前CPU的scheduler线程，再将上下文切换到需要运行的进程的内核线程，最后返回用户空间。</p>
<p>从一个内核线程切换到另一个线程需要保存旧线程的寄存器，恢复新线程之前保存的寄存器。<code>sp</code>和<code>pc</code>将在此过程中被保存和切换。<code>swtch</code>可以实现这种寄存器组状态(也叫上下文)的保存和切换。当进程需要<code>yield</code>CPU时，这个进程的内核线程将调用<code>swtch</code>来保存上下文并切换到scheduler的上下文，所有的上下文都保存在<code>struct context</code>中。<code>swtch</code>的传入参数为<code>struct context *old</code>和<code>struct context *new</code></p>
<p><code>yield()</code>函数切换了进程的状态为RUNNABLE，调用了<code>sched()</code>。<code>sched</code>调用了<code>swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context)</code>来将上下文切换到<code>cpu-&gt;scheduler</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sched(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> intena;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  intena = mycpu()-&gt;intena;</span><br><span class="line">  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">  mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sched()</code>中，先要检查是否还获取着<code>p-&gt;lock</code>，防止其他CPU的scheduler看见<code>p-&gt;state==RUNNABLE</code>的情况下试图去运行这个进程。通过检查<code>mycpu()-&gt;noff</code>来检查是否还获取着除了<code>p-&gt;lock</code>之外的其他锁，否则当切换到其他进程之后其他进程可能会<code>acquire</code>这个锁，而原先的进程由于没有在运行，因此一直无法释放掉这个锁，造成死锁。</p>
<p><code>swtch</code>只保存callee saved寄存器，caller saved寄存器在栈中被调用的代码保存。<code>swtch</code>并没有保存<code>pc</code>寄存器，而是保存了<code>ra</code>，当恢复了新的进程之前保存的<code>ra</code>寄存器后，将返回到<code>ra</code>寄存器指向的上一个进程调用<code>swtch</code>的代码。如果保存<code>pc</code>寄存器，将只能回到<code>swtch</code>本身。由于切换到的<code>&amp;mycpu()-&gt;context</code>是被<code>scheduler</code>对<code>swtch</code>的调用所保存的，因此当进行<code>swtch</code>时，我们将返回到<code>scheduler</code>，栈指针也将指向当前CPU的scheduler stack。</p>
<h3 id="8-3-Scheduling">8.3 Scheduling</h3>
<p>调度器(scheduler)是每个CPU中都会运行的一个特殊的线程，这个线程中不断运行<code>scheduler</code>函数，来选取下一个需要运行的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run.</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">        nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nproc &lt;= <span class="number">2</span>) &#123;   <span class="comment">// only init and sh exist</span></span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要<code>yield</code>CPU的进程首先要获取自己进程的锁<code>p-&gt;lock</code>（防止其他CPU获取这个进程），修改当前的状态到<code>RUNNABLE</code>，<code>release</code>掉自己获取的其他锁，加载<code>cpu-&gt;scheduler</code>的上下文，返回到<code>scheduler()</code>之后，<code>release</code>掉自己的进程锁。</p>
<p>在<code>scheduler</code>调用<code>swtch</code>到新的进程之前，<code>scheduler</code>需要已经获取这个进程的锁，并且将对这个进程的锁传递给被切换到的这个新的进程中，让新进程来<code>release</code>这个锁。一般来说，一个锁应该由<code>acquire</code>它的进程来进行<code>release</code>，但是由于一个进程的<code>p-&gt;state</code>是在<code>scheduler</code>中被改变的，需要对其进行保护，因此需要在<code>scheduler</code>中就获取这个进程的锁</p>
<p>当一个新的进程是第一次被<code>scheduler</code>调度的时候，不返回到<code>sched</code>，而是返回到<code>forkret</code>（因为之前并没有从<code>sched</code>中调用过<code>swtch</code>）。<code>forkret</code>将<code>p-&gt;lock</code>释放掉，然后回到<code>usertrapret</code>。</p>
<h3 id="8-4-mycpu-and-myproc">8.4 mycpu and myproc</h3>
<p>xv6为每一个CPU都有一个<code>struct cpu</code>，记录当前运行在这个CPU上的进程的指针<code>struct proc *proc</code>、保存的寄存器<code>struct context context</code>、<code>push_off</code>的nesting的数量<code>int noff</code>等变量。</p>
<p>RISC-V将所有CPU进行编号，该编号称为<em>hartid</em>，确保每个CPU的hartid都保存在这个CPU的<code>tp</code>寄存器内，可以让<code>mycpu</code>通过这个hartid来索引到一个<code>struct cpu</code>数组<code>cpus[]</code>中，从而获取对当前CPU的<code>struct cpu</code>的引用。当获取<code>struct cpu</code>之后如果发生了中断导致CPU被切换了，那么获取的<code>struct cpu</code>将是不正确的，因此需要用<code>push_off</code>来保证当前的中断使能被关闭。</p>
<p>使用<code>myproc()</code>函数来返回一个指向当前CPU运行的进程<code>c-&gt;proc</code>的指针。</p>
<h3 id="8-5-sleep-and-wakeup">8.5 sleep and wakeup</h3>
<p>调度和锁有助于隐藏一个进程对另一个进程的存在，但到目前为止，我们还没有帮助进程进行有意交互的抽象。为解决这个问题已经发明了许多机制。Xv6使用了一种称为<code>sleep</code>和<code>wakeup</code>的方法，它允许一个进程在等待事件时休眠，而另一个进程在事件发生后将其唤醒。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">semaphore</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">wakeup</span>(s);</span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">sleep</span>(s, &amp;s-&gt;lock);  <span class="comment">// !pay attention</span></span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们考虑一个称为**信号量（semaphore）**的同步机制，它可以协调生产者和消费者。信号量维护一个计数并提供两个操作。“V”操作（对于生产者）增加计数。“P”操作（对于使用者）等待计数为非零，然后递减并返回。</p>
<p>注意，我们需要使得“P”操作中1️⃣判断<code>s-&gt;count == 0</code>和<code>sleep()</code>2️⃣<code>sleep()</code>释放<code>s-&gt;lock</code>并使消费者进程进入睡眠状态这两个操作是原子的，因此在“P”操作开始获取锁，并在<code>sleep()</code>中传递锁</p>
<h2 id="Lecture-9-File-systems">Lecture 9 File systems</h2>
<p>文件系统的目的是组织和存储数据。文件系统通常支持用户和应用程序之间的数据共享，以及持久性，以便在重新启动后数据仍然可用。</p>
<h3 id="9-1概述">9.1概述</h3>
<p>xv6文件系统实现分为七层（如下表），<strong>磁盘层</strong>和<strong>缓存层</strong>负责底层的物理I/O、缓存及并发访问控制；<strong>日志层</strong>通过事务机制确保多块更新的原子性以实现崩溃恢复；<strong>索引结点层</strong>、<strong>目录层</strong>和<strong>路径名层</strong>共同构建了文件的结构、命名和分层路径解析；最上层的<strong>文件描述符层</strong>则将文件、管道等资源统一抽象，为应用程序提供了简便的接口。</p>
<table>
<thead>
<tr>
<th>文件描述符（File descriptor）</th>
</tr>
</thead>
<tbody>
<tr>
<td>路径名（Pathname）</td>
</tr>
<tr>
<td>目录（Directory）</td>
</tr>
<tr>
<td>索引结点（Inode）</td>
</tr>
<tr>
<td>日志（Logging）</td>
</tr>
<tr>
<td>缓冲区高速缓存（Buffer cache）</td>
</tr>
<tr>
<td>磁盘（Disk）</td>
</tr>
</tbody>
</table>
<p>xv6将磁盘划分为几个部分，如图8.2所示。</p>
<p>块0为引导扇区，文件系统不适用。块1为超级块，包含有关文件系统的元数据。从块2开始为日志块。日志块之后是索引节点块，索引节点块之后是位图块，跟踪正在使用的数据块。其余的块则为数据块。</p>
<p><img src="/images/6.S081notes-15.png" alt></p>
<h3 id="9-2-Buffer-cache层">9.2 Buffer cache层</h3>
<p>Buffer cache层有两个任务：</p>
<ol>
<li>同步对磁盘块的访问，以确保磁盘块在内存中只有一个副本，并且一次只有一个内核线程使用该副本</li>
<li>缓存常用块，以便不需要从慢速磁盘重新读取它们。代码在<code>bio.c</code>中。</li>
</ol>
<p>Buffer cache层导出的主接口主要是<code>bread</code>和<code>bwrite</code>，前者读取一个<code>buf</code>，包含可修改块的副本；后者可以将修改后的<code>buf</code>写入磁盘中的相应块。</p>
<p>Buffer cache每个缓冲区使用一个睡眠锁，以确保每个缓冲区每次只被一个线程使用；<code>bread</code>返回一个上锁的缓冲区，<code>brelse</code>释放该锁。</p>
<h3 id="9-3-日志层">9.3 日志层</h3>
<p>xv6 使用一种 <strong>简化的日志</strong> 来确保文件系统操作的原子性。</p>
<p>操作过程：</p>
<ol>
<li><strong>记录阶段</strong></li>
</ol>
<ul>
<li>系统调用不会直接修改磁盘结构。</li>
<li>它会先把“想写的磁盘块”信息<strong>写入日志区域（log）</strong>。</li>
</ul>
<ol start="2">
<li><strong>提交阶段（commit）</strong></li>
</ol>
<ul>
<li>当所有要写的操作都记录完毕后，写入一条 <strong>commit 记录</strong>，表示该操作完整。</li>
<li>然后将这些修改从日志复制到真正的文件系统区域。</li>
</ul>
<ol start="3">
<li><strong>清理阶段</strong></li>
</ol>
<ul>
<li>写入完成后，<strong>清空日志区域</strong>，为下次操作准备</li>
</ul>
<p><strong>崩溃恢复过程：</strong></p>
<ul>
<li>
<p>若日志中存在 <strong>完整的 commit 记录</strong> →<br>
<strong>重放（replay）</strong> 日志，把所有操作复制到磁盘正确位置。</p>
</li>
<li>
<p>若日志 <strong>不完整（无 commit）</strong> →<br>
<strong>忽略</strong> 日志，保持原磁盘状态不变。</p>
</li>
<li>
<p>最后清空日志。</p>
</li>
</ul>
<p>也就是说日志机制使文件系统操作在崩溃时表现为**“要么全做，要么全不做”**，操作是原子的</p>
<h3 id="9-4-日志设计">9.4 日志设计</h3>
<p>日志位于磁盘的<strong>固定区域</strong>，由头块和日志块组成，其中头块会记录日志块的数量count.，在日志成功提交（commit）才写入头块</p>
<p><strong>每个系统调用（syscall call）</strong> 定义一个原子写入序列，为提高性能，<strong>多个系统调用的写入可以合并为一个事务</strong>（组提交）。注意：日志系统只在“没有系统调用在进行”时提交事务，确保<strong>系统调用不会被拆分到多个事务中</strong></p>
<h3 id="9-5-索引结点层">9.5 索引结点层</h3>
<p>inode有两种形式，分别为：磁盘上的inode和内存中的inode。</p>
<p>前者存在于磁盘上，保存文件的<strong>元数据</strong>，后者是磁盘 inode 的<strong>副本</strong>，外加内核运行所需的附加信息</p>
<p>xv6的inode代码中有四种锁或类似锁的机制：<code>icache.lock</code>（全局缓存锁）、<code>inode.lock</code>（每个 inode 的睡眠锁）、<code>ref</code> 引用计数、<code>nlink</code>（链接计数）</p>
<p>关键函数<code>iget(dev, inum)</code>从缓存中获取 inode 指针（若不存在则创建），并增加 <code>ref</code></p>
<p><code>iput(inode)</code>释放对 inode 的引用，若引用数降至 0，可能清理缓存项</p>
<p>还有<code>ilock(inode)</code>、<code>iunlock(inode)</code>、<code>iupdate(inode)</code></p>
<p>inode 缓存是 <strong>直写</strong>：一旦修改就写盘，不做延迟写</p>
<h3 id="9-6-Code：Inode包含内容">9.6 Code：Inode包含内容</h3>
<p>磁盘上的inode结构体<code>struct dinode</code>包含一个<code>size</code>和一个块号数组（见图8.3）</p>
<p>块号布局：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addrs<span class="selector-attr">[0..NDIRECT-1]</span> → 直接块（Direct blocks）</span><br><span class="line">addrs<span class="selector-attr">[NDIRECT]</span>       → 间接块（Indirect block）</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>直接块（12 个）：可直接定位文件前 12×BSIZE 字节；</p>
</li>
<li>
<p>间接块：存放一个数组，列出后续 256 个数据块的地址；</p>
</li>
<li>
<p>因此文件最大约为 (NDIRECT + NINDIRECT) × BSIZE。</p>
</li>
</ul>
<h3 id="9-7-文件描述符层">9.7 文件描述符层</h3>
<p>Unix 将控制台、管道、真实文件等资源统一抽象为文件。Xv6 通过以下结构实现这一层：</p>
<ul>
<li><strong><code>struct file</code> (打开文件表示):</strong> 每个打开的文件由一个 <code>struct file</code> 结构体表示。它包含：
<ul>
<li><strong>封装对象:</strong> 指向底层 <code>inode</code> 或 <code>pipe</code> 的指针。</li>
<li><strong>I/O 偏移量 (Offset):</strong> 当前读写的位置。</li>
<li><strong>访问权限:</strong> <code>readable</code> 和 <code>writable</code> 标志。</li>
<li><strong>引用计数 (Reference Count):</strong> 跟踪有多少个文件描述符指向该结构。</li>
</ul>
</li>
</ul>
<hr>
<p>理解 <code>struct file</code> 的创建与共享方式对于理解并发行为至关重要：</p>
<table>
<thead>
<tr>
<th><strong>操作场景</strong></th>
<th><strong>行为描述</strong></th>
<th><strong>I/O 偏移量状态</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>多次 <code>open</code></strong></td>
<td>即使是同一个文件，每次 <code>open</code> 都会创建一个<strong>新</strong>的 <code>struct file</code>。</td>
<td><strong>独立</strong> (每个进程有自己的读写位置)</td>
</tr>
<tr>
<td><strong><code>dup</code> 或 <code>fork</code></strong></td>
<td>创建别名，<strong>共享</strong>同一个 <code>struct file</code>。</td>
<td><strong>共享</strong> (父子进程或别名共享同一个读写位置)</td>
</tr>
</tbody>
</table>
<hr>
<p>系统中所有打开的文件都存储在一个全局表 <strong><code>ftable</code></strong> 中，并通过以下函数进行生命周期管理：</p>
<ul>
<li><strong><code>filealloc</code>:</strong> 扫描表寻找未使用的槽位 (<code>ref == 0</code>) 并分配新引用。</li>
<li><strong><code>filedup</code>:</strong> 增加文件的引用计数。</li>
<li><strong><code>fileclose</code>:</strong> 减少引用计数。当计数归零时，根据文件类型释放底层的管道或 inode。</li>
</ul>
<hr>
<p>文件操作函数 (<code>fileread</code>, <code>filewrite</code>, <code>filestat</code>) 负责将请求转发给底层的 inode 或管道实现：</p>
<ul>
<li>
<p><strong>权限检查:</strong> 操作前会检查打开模式（如是否允许写入）。</p>
</li>
<li>
<p><strong>偏移量更新:</strong> 对于 inode，读写操作使用并更新偏移量。管道（Pipe）没有偏移量的概念。</p>
</li>
<li>
<p><strong>原子性与锁:</strong></p>
<blockquote>
<p><strong>关键点：</strong> Inode 函数要求调用者持有锁。这种机制有一个重要的副作用：<strong>读写偏移量的更新是原子的</strong>。这意味着即使多个进程并发写入同一个共享文件，它们的数据可能会交错，但不会互相覆盖（overwrite）彼此正在写入的数据段。</p>
</blockquote>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://taffy128.github.io/">lzx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://taffy128.github.io/2025/11/28/6-S081-Lecture-Notes/">https://taffy128.github.io/2025/11/28/6-S081-Lecture-Notes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://taffy128.github.io" target="_blank">lzx's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">C++学习笔记</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/06/CSAPP-DataLab-01/" title="CSAPP_DataLab_01"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CSAPP_DataLab_01</div></div><div class="info-2"><div class="info-item-1">万事开头难，尤其是和 0 与 1 打交道，和后面的实验相比，这次只能算个热身。但是喜欢运动的都知道，热身很重要！ 任务目标 我们先来看看 Datalab 需要我们做什么。主要是通过这次的作业来熟悉整型及浮点数的位表达形式，简单来说，就是解开一些人工谜题。列表如下： 比特操作谜题：    名称 描述 难度 指令数目     bitXor(x,y) 只用 &amp; 和 ~ 实现 x^y 1 14   allOddBits(x) 所有的奇数位都为 1 吗 2 12   isAsciiDigit(x) x 是 ASCII 码吗 3 15   conditional(x, y, z) 类似于 C 语言中的 x? y:z 3 16   logicalNeg(x) 计算 !x 而不用 ! 运算符 4 12    整数运算谜题：    名称 描述 难度 指令数目     tmin() 返回最小的补码 1 4   isTmax(x) x 是最大的 32 位补码 2 10   negate(x) 不用负号得到 -x 3 24   isLessOrEqual(x,y) x &lt;=...</div></div></div></a><a class="pagination-related" href="/2025/11/28/6-S081-Lab10-Mmap/" title="6.S081_Lab10_Mmap"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">6.S081_Lab10_Mmap</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab10_Mmap 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab10地址 课程首页 Lab10 核心数据结构 实现 mmap 的核心数据结构是 Linux 中的 vm_area_struct，下面是 CSAPP 的经典好图：  start 和 end 是一个左闭右开的区间，即 [start, end) 在 Linux 内核中，VMA 是通过红黑树以起始地址为关键字来实现快速增删改查的，在这个 Lab 实现中，我就用单链表来把 VMA 串一起就行了，因此 struct vma 的定义如下： 123456789struct vma &#123;  uint64 start;  uint64 end;  int prot;  int flags;...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/09/13/6-S081-Lab0-Environment-Setup/" title="6.S081_Lab0_Environment Setup"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-13</div><div class="info-item-2">6.S081_Lab0_Environment Setup</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab0_Environment Setup 写在前面 本文旨在为 MIT 6.S081: Operating System Engineering (RISC-V 版本) 的学习者提供一份完整、详尽的开发与调试环境搭建步骤。一个配置完善的环境是高效完成课程实验、深入理解操作系统内核的关键。本教程将引导你完成从安装工具链到配置图形化调试环境的全过程。 第一部分：基础概念 在开始配置前，理解以下几个核心概念，有助于清晰地认识整个开发与调试工作流。 1.1. 宿主机 (Host) 与客户机 (Guest) 整个开发过程涉及两个相互独立的系统环境：  宿主操作系统 (Host OS)：这是你用于开发和编译的系统，通常是一个 Linux 发行版（如 Ubuntu）。所有的开发工具，包括编译器、模拟器和调试器，都安装并运行在宿主机上。 客户操作系统 (Guest OS)：这是你正在学习和开发的操作系统，即 xv6。它运行在由模拟器创建的独立虚拟环境中。  1.2. QEMU 的角色 QEMU 是一个开源的系统模拟器。在本课程中，它的作用是提供一个完整的、软件模拟的...</div></div></div></a><a class="pagination-related" href="/2025/09/13/6-S081-Lab2-System-calls/" title="6.S081_Lab2_System calls"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-13</div><div class="info-item-2">6.S081_Lab2_System calls</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab2_System calls 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab2地址 课程首页 0.Makefile 每个任务完成之后需要在Makefile中添加对应的信息才能运行 在UPROGS项下添加以下内容： 12$U/_trace\$U/_sysinfotest\ 1.System call tracing 要求：trace [tracing_mask] [command] 要求当调用了给定的tracing mask所对应的system call时，打印输出调用该system call的进程PID、system call的名称、system call的返回值。已经给出了user...</div></div></div></a><a class="pagination-related" href="/2025/11/28/6-S081-Lab10-Mmap/" title="6.S081_Lab10_Mmap"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-28</div><div class="info-item-2">6.S081_Lab10_Mmap</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab10_Mmap 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab10地址 课程首页 Lab10 核心数据结构 实现 mmap 的核心数据结构是 Linux 中的 vm_area_struct，下面是 CSAPP 的经典好图：  start 和 end 是一个左闭右开的区间，即 [start, end) 在 Linux 内核中，VMA 是通过红黑树以起始地址为关键字来实现快速增删改查的，在这个 Lab 实现中，我就用单链表来把 VMA 串一起就行了，因此 struct vma 的定义如下： 123456789struct vma &#123;  uint64 start;  uint64 end;  int prot;  int flags;...</div></div></div></a><a class="pagination-related" href="/2025/09/27/6-S081-Lab4-Traps/" title="6.S081_Lab4_Traps"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-27</div><div class="info-item-2">6.S081_Lab4_Traps</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab4_Traps 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab4地址 课程首页 1.RISC-V assembly 要求：使用make fs.img编译，得到user/call.asm文件，通过阅读call.asm，了解g、f和main函数，并回答以下问题   Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf? a1 里存 12（第一个参数），a2 里存 13（第二个参数），a1、a2 包含函数参数。    Where is the call to function f...</div></div></div></a><a class="pagination-related" href="/2025/09/13/6-S081-Lab1-Unix-Utilities/" title="6.S081_Lab1_Unix Utilities"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-13</div><div class="info-item-2">6.S081_Lab1_Unix Utilities</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab1_Unix Utilities 写在前面 这是本课程第一次正式Lab，自行完成需要耗费一定的时间 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab1地址 课程首页 0.Makefile 每个任务完成之后需要在Makefile中添加对应的信息才能运行 在UPROGS项下添加以下内容： 12345$U/_sleep\$U/_pingpong\$U/_primes\$U/_find\$U/_xargs\ 1.Sleep 通过sleep系统调用来实现休眠一定时间，注意如果没有传入参数，程序需要打印错误信息 1234567891011#include &quot;kernel/types.h&quot;#include...</div></div></div></a><a class="pagination-related" href="/2025/09/20/6-S081-Lab3-page-tables/" title="6.S081_Lab3_page tables"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-20</div><div class="info-item-2">6.S081_Lab3_page tables</div></div><div class="info-2"><div class="info-item-1">6.S081_Lab3_page tables 写在前面 如果一行代码都还没有写，不知道完全要在哪里写，写什么东西，说明是对xv6的相关机制不懂，继续反复阅读xv6book 如果是写了一些代码，但是运行不起来，或者运行情况与预期不符，可以尝试询问AI或者用gdb逐行调试 如果已经花费了超额时间（例如easy题目仅做题时间超过1.5h），可以尝试阅读别人的源码，但是一定不要边看边写，要彻底看懂后自己完整的敲出来 Lab3地址 课程首页 1.Speed up system calls 要求：通过在内核与用户空间之间共享一个只读内存页来加速getpid()系统调用，具体做法是在创建进程时分配一个物理页、存入PID，然后将其以只读方式映射到用户虚拟地址USYSCALL，并在进程退出时释放它，从而让用户程序可以直接从内存读取PID，避免陷入内核。 这个 task 的难点在于，你应该把 map page 这段代码放在哪里最合适？Lab 文档里说的是 When each process is created，具体是什么时候呢？是放在 fork 的地方，还是放在 allocproc...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">lzx</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Taffy128"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Taffy128" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:yyangguangnanhai9@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">6.S081_Lecture Notes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-1-Introduction"><span class="toc-number">1.1.</span> <span class="toc-text">Lecture 1 Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Processes-and-memory"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 Processes and memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-I-O-and-File-descriptors"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 I&#x2F;O and File descriptors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Pipes"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 Pipes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-File-system"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 File system</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-2-Operating-System-Organization"><span class="toc-number">1.2.</span> <span class="toc-text">Lecture 2 Operating System Organization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-User-mode-and-supervisor-mode"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 User mode and supervisor mode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Kernel-organization"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 Kernel organization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Process"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 Process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Starting-the-first-process"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 Starting the first process</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-3-Page-Tables"><span class="toc-number">1.3.</span> <span class="toc-text">Lecture 3 Page Tables</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Paging-Hardware"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 Paging Hardware</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Kernel-address-space"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 Kernel address space</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Code-creating-an-address-space"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 Code: creating an address space</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Physical-memory-allocation-for-kernel"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 Physical memory allocation for kernel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-User-space-memory"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 User space memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-Code-exec"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 Code: exec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-Real-world"><span class="toc-number">1.3.7.</span> <span class="toc-text">3.7 Real world</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-4-RISC-V-calling-convention"><span class="toc-number">1.4.</span> <span class="toc-text">Lecture 4 RISC-V calling convention</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-ISA-Assembly-Language"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 ISA &amp; Assembly Language</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Calling-convention"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 Calling convention</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Stack"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 Stack</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-5-Traps"><span class="toc-number">1.5.</span> <span class="toc-text">Lecture 5 Traps</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-0-trap"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.0 trap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-RISC-V-trap-machinery"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.1 RISC-V trap machinery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Traps-from-user-space"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.2 Traps from user space</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Calling-system-calls"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.3 Calling system calls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Traps-from-kernel-space"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.4 Traps from kernel space</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-6-Interrupts"><span class="toc-number">1.6.</span> <span class="toc-text">Lecture 6 Interrupts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Console-input"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 Console input</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Console-output"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 Console output</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Timer-interrupts"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 Timer interrupts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Real-world"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 Real world</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-7-Locking"><span class="toc-number">1.7.</span> <span class="toc-text">Lecture 7 Locking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Race-conditions"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 Race conditions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Code-Locks"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 Code: Locks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-Deadlocks-and-lock-ordering"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 Deadlocks and lock ordering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-Sleep-locks"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4 Sleep locks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-RCU"><span class="toc-number">1.7.5.</span> <span class="toc-text">7.5 RCU</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-8-Scheduling"><span class="toc-number">1.8.</span> <span class="toc-text">Lecture 8 Scheduling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-Multiplexing"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 Multiplexing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-Context-Switching"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 Context Switching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-Scheduling"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 Scheduling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-mycpu-and-myproc"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4 mycpu and myproc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-sleep-and-wakeup"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5 sleep and wakeup</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-9-File-systems"><span class="toc-number">1.9.</span> <span class="toc-text">Lecture 9 File systems</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.9.1.</span> <span class="toc-text">9.1概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-Buffer-cache%E5%B1%82"><span class="toc-number">1.9.2.</span> <span class="toc-text">9.2 Buffer cache层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E6%97%A5%E5%BF%97%E5%B1%82"><span class="toc-number">1.9.3.</span> <span class="toc-text">9.3 日志层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E6%97%A5%E5%BF%97%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.9.4.</span> <span class="toc-text">9.4 日志设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9%E5%B1%82"><span class="toc-number">1.9.5.</span> <span class="toc-text">9.5 索引结点层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-Code%EF%BC%9AInode%E5%8C%85%E5%90%AB%E5%86%85%E5%AE%B9"><span class="toc-number">1.9.6.</span> <span class="toc-text">9.6 Code：Inode包含内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B1%82"><span class="toc-number">1.9.7.</span> <span class="toc-text">9.7 文件描述符层</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/06/CSAPP-DataLab-01/" title="CSAPP_DataLab_01">CSAPP_DataLab_01</a><time datetime="2025-12-06T10:07:38.766Z" title="发表于 2025-12-06 18:07:38">2025-12-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/28/6-S081-Lecture-Notes/" title="6.S081_Lecture Notes">6.S081_Lecture Notes</a><time datetime="2025-11-28T10:45:48.815Z" title="发表于 2025-11-28 18:45:48">2025-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/28/6-S081-Lab10-Mmap/" title="6.S081_Lab10_Mmap">6.S081_Lab10_Mmap</a><time datetime="2025-11-28T10:43:14.371Z" title="发表于 2025-11-28 18:43:14">2025-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/26/6-S081-Lab9-File-system/" title="6.S081_Lab9_File system">6.S081_Lab9_File system</a><time datetime="2025-11-26T12:18:38.190Z" title="发表于 2025-11-26 20:18:38">2025-11-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/24/6-S081-Lab8-locks/" title="6.S081_Lab8_locks">6.S081_Lab8_locks</a><time datetime="2025-11-24T14:30:04.484Z" title="发表于 2025-11-24 22:30:04">2025-11-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By lzx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>